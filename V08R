"""
V08R — REFRESHED (NO GLE, NO Objective)

What this file does:
- Reports two heights of application for the pseudo-static resultant:
  1) h_ps(ME): Moment-Equilibrium height at alpha_failure = argmax P_AE
     • Regime A: unchanged from V07/V08 mechanics (includes wedge-1 term when P_1E>0).
     • Regime B: UPDATED to include + KH * W_ps * Z_ps (vertical centroid of pseudo body).
  2) h_ps(S&W): Seed & Whitman height using the full static envelope P_A,max (NOT reduced-static)

Conventions (consistent with your V07/V08):
- Pseudo-static body = dead + pavement; surcharge is EXCLUDED from pseudo-static weights.
- Static body = dead + pavement + surcharge.
- Rule 2 (Regime A): Wedge-1 is included in P_A (static) only if P_1 > 0, and in P_AE (pseudo) only if P_1E > 0.
- Units are unit-agnostic; typical US: ft, pcf/psf, outputs lb/ft. Keep consistent units.

NOTE:
- Objective placement and any supporting quantities (Z_ps/h_st^(AR) outside the new Regime B ME term) are removed.
- Only Z_ps needed for Regime B ME is computed locally inside eval_regimeB.
"""
from __future__ import annotations
import math
import numpy as np
from typing import Dict

rad = math.radians

def thrust_P(W: float, theta_deg: float, phi_deg: float, c_prime: float, Lc: float, kh_val: float) -> float:
    s = math.sin(rad(theta_deg)); c = math.cos(rad(theta_deg)); tphi = math.tan(rad(phi_deg))
    den = c + s * tphi
    if abs(den) < 1e-12: den = 1e-12
    return (W * ((s - c * tphi) + kh_val * (c + s * tphi)) - c_prime * Lc) / den

def alpha_crit_from_geometry(h1: float, h2: float, beta_deg: float) -> float:
    Hs = h1 + h2
    beta = rad(beta_deg)
    return math.degrees(math.atan((Hs * math.tan(beta)) / h2))

# ---------- Regime A geometry & wedge-2 areas/centroids ----------

def regimeA_geometry(alpha: float, beta: float, h1: float, h2: float):
    ta = math.tan(rad(alpha)); tb = math.tan(rad(beta)); H = h1 + h2
    if abs(ta - tb) < 1e-12: ta += 1e-12
    h_soil = h1 * ta / (ta - tb)
    h_BC   = H - h_soil
    L1     = h_BC / math.tan(rad(beta))
    LBO    = L1 / math.cos(rad(beta))
    L2     = h2 / math.tan(rad(beta)) - L1
    LAB    = h_soil / math.sin(rad(alpha))
    return H, h_soil, h_BC, L1, LBO, L2, LAB

def wedge2_regimeA_areas_centroids(alpha: float, beta: float, h1: float, h2: float):
    H, h_soil, h_BC, L1, LBO, L2, LAB = regimeA_geometry(alpha, beta, h1, h2)
    V_soil2 = 0.5 * h1 * L2
    x_S2 = L2 / 3.0
    z_S2 = (h1 + h_soil) / 3.0
    V_LCC2 = L2 * (H - 0.5 * (h1 + h_soil))
    denom = (2*H - h1 - h_soil)
    if abs(denom) < 1e-12:
        x_L2 = L2 / 2.0; z_L2 = (H + h1) / 2.0
    else:
        x_L2 = L2 * (3*H - h1 - 2*h_soil) / (3 * denom)
        z_L2 = (H*H - (h_soil*h_soil + h1*h1 + h1*h_soil)/3.0) / denom
    return dict(H=H, h_soil=h_soil, h_BC=h_BC, L1=L1, LBO=LBO, L2=L2, LAB=LAB,
                V_soil2=V_soil2, x_S2=x_S2, z_S2=z_S2, V_LCC2=V_LCC2, x_L2=x_L2, z_L2=z_L2)

# ---------- Regime B geometry ----------

def regimeB_geometry(alpha: float, beta: float, h1: float, h2: float):
    H = h1 + h2
    L2 = H / math.tan(rad(alpha))
    LAB = H / math.sin(rad(alpha))
    V_LCC = 0.5 * h2 * h2 / math.tan(rad(beta))
    V_tot = 0.5 * H * H / math.tan(rad(alpha))
    V_soil = V_tot - V_LCC
    return H, L2, LAB, V_LCC, V_soil

# ---------- Evaluate Regime A at alpha ----------

def eval_regimeA(alpha: float, beta: float, phi: float, c_prime: float,
                 h1: float, h2: float, h3: float,
                 gam_soil: float, gam_lcc: float, gam_pav: float, surch: float,
                 KH: float) -> Dict:
    g = wedge2_regimeA_areas_centroids(alpha, beta, h1, h2)
    H, h_soil, h_BC, L1, LBO, L2, LAB = g['H'], g['h_soil'], g['h_BC'], g['L1'], g['LBO'], g['L2'], g['LAB']
    # Weights
    W_soil2 = gam_soil * g['V_soil2']; W_LCC2 = gam_lcc * g['V_LCC2']
    Wp2 = gam_pav * h3 * L2; Wt2 = surch * L2
    W2_body = W_soil2 + W_LCC2
    W2_st = W2_body + Wp2 + Wt2            # static body includes surcharge
    W2_ps = W2_body + Wp2                  # pseudo-static body excludes surcharge
    # Pseudo centroid arms
    x2_ps = (W2_body*((W_soil2*g['x_S2'] + W_LCC2*g['x_L2'])/(W2_body if W2_body else 1)) + Wp2*(L2/2.0))/(W2_ps if W2_ps else 1)
    z2_ps = (W2_body*((W_soil2*g['z_S2'] + W_LCC2*g['z_L2'])/(W2_body if W2_body else 1)) + Wp2*(H/2.0))/(W2_ps if W2_ps else 1)
    g_ps = x2_ps / math.cos(rad(alpha))
    # Wedge 1 (LCC on BC + pavement on BC if any)
    V_LCC1 = 0.5 * L1 * h_BC; W_LCC1 = gam_lcc * V_LCC1
    Wp1 = gam_pav * h3 * L1; Wt1 = surch * L1
    W1_st = W_LCC1 + Wp1 + Wt1
    W1_ps = W_LCC1 + Wp1
    # Thrusts
    P1    = thrust_P(W1_st, beta,  phi, c_prime, LBO, 0.0)
    P1_ps = thrust_P(W1_ps, beta,  phi, c_prime, LBO, KH)
    P2    = thrust_P(W2_st, alpha, phi, c_prime, LAB, 0.0)
    P2_ps = thrust_P(W2_ps, alpha, phi, c_prime, LAB, KH)
    include1S = (P1    > 0.0)     # Rule 2 (static)
    include1E = (P1_ps > 0.0)     # Rule 2 (pseudo)
    PA  = (P1 if include1S else 0.0) + P2
    PAE = (P1_ps if include1E else 0.0) + P2_ps
    # Moment-equilibrium pseudo height (Regime A)
    N_ps = W2_ps * math.cos(rad(alpha)) - KH * W2_ps * math.sin(rad(alpha)) + P2_ps * math.sin(rad(alpha))
    z1B_ps = (W_LCC1*(h_BC*2.0/3.0) + Wp1*(h_BC/2.0)) / (W1_ps if W1_ps else 1)
    if not include1E:
        M1_ps = 0.0
    else:
        if P1 <= 0.0:
            zp1_ps = z1B_ps
        else:
            S1 = W_LCC1*(L1/3.0) + Wp1*(L1/2.0)
            e1B_ps = S1 / (W1_ps if W1_ps else 1)
            g1_ps = e1B_ps / math.cos(rad(beta))
            N1_ps = W1_ps * math.cos(rad(beta)) - KH * W1_ps * math.sin(rad(beta)) + P1_ps * math.sin(rad(beta))
            zp1_ps = (g1_ps * N1_ps - S1 + KH * W1_ps * z1B_ps) / (P1_ps if P1_ps else 1)
            if zp1_ps < 0.0: zp1_ps = 0.0
            if zp1_ps > h_BC: zp1_ps = h_BC
        M1_ps = (P1_ps if include1E else 0.0) * (zp1_ps + h_soil)
    h_ps_ME = (g_ps * N_ps - W2_ps * x2_ps + KH * W2_ps * z2_ps + M1_ps) / (PAE if abs(PAE) > 1e-12 else float('nan'))
    # Static height (info only)
    x2_tot = (W_soil2*g['x_S2'] + W_LCC2*g['x_L2'] + Wp2*(L2/2.0) + Wt2*(L2/2.0)) / (W2_st if W2_st else 1)
    gst = x2_tot / math.cos(rad(alpha))
    N_st = W2_st * math.cos(rad(alpha)) + P2 * math.sin(rad(alpha))
    M1_st = 0.0
    if include1S and abs(P1) > 1e-12:
        S1 = W_LCC1*(L1/3.0) + Wp1*(L1/2.0) + Wt1*(L1/2.0)
        e1B_st = S1 / (W1_st if W1_st else 1)
        g1_st = e1B_st / math.cos(rad(beta))
        N1_st = W1_st * math.cos(rad(beta)) + P1 * math.sin(rad(beta))
        zp1_st = (g1_st * N1_st - S1) / (P1 if abs(P1)>1e-12 else 1)
        if zp1_st < 0.0: zp1_st = 0.0
        if zp1_st > h_BC: zp1_st = h_BC
        M1_st = P1 * (zp1_st + h_soil)
    h_st = (gst * N_st - W2_st * x2_tot + M1_st) / (PA if abs(PA) > 1e-12 else float('nan'))
    return dict(alpha=alpha, PA=PA, h_st=h_st, PAE=PAE, h_ps=h_ps_ME)

# ---------- Evaluate Regime B at alpha (UPDATED ME with + KH*W_ps*Z_ps) ----------

def eval_regimeB(alpha: float, beta: float, phi: float, c_prime: float,
                 h1: float, h2: float, h3: float,
                 gam_soil: float, gam_lcc: float, gam_pav: float, surch: float,
                 KH: float) -> Dict:
    H, L2, LAB, V_LCC, V_soil = regimeB_geometry(alpha, beta, h1, h2)
    # Weights
    W_LCC = gam_lcc * V_LCC; W_soil = gam_soil * V_soil
    W_body= W_LCC + W_soil
    Wp = gam_pav * h3 * L2; Wt = surch * L2
    W_st = W_body + Wp + Wt
    W_ps = W_body + Wp
    # Thrusts
    P_st = thrust_P(W_st, alpha, phi, c_prime, LAB, 0.0)
    P_ps = thrust_P(W_ps, alpha, phi, c_prime, LAB, KH)
    # Pseudo centroid x and z (Regime B)
    # Horizontal: soil centroid from (total - LCC) polygon; pavement at L2/2
    x_tot = (H / math.tan(rad(alpha))) / 3.0
    x_LCC = (h2 / math.tan(rad(beta))) / 3.0
    A_tot = 0.5 * H * H / math.tan(rad(alpha))
    A_LCC = 0.5 * h2 * h2 / math.tan(rad(beta))
    A_soil= A_tot - A_LCC if A_tot - A_LCC != 0 else 1.0
    x_soil= (A_tot * x_tot - A_LCC * x_LCC) / A_soil
    x_body= (W_soil * x_soil + W_LCC * x_LCC) / (W_body if W_body else 1)
    x_ps = (W_body * x_body + Wp * (L2/2.0)) / (W_ps if W_ps else 1)
    g_ps = x_ps / math.cos(rad(alpha))
    # Vertical: soil/LCC vertical centroids, pavement at H/2
    z_tot = 2 * H / 3.0; z_LCC = h1 + 2 * h2 / 3.0
    z_soil= (A_tot * z_tot - A_LCC * z_LCC) / A_soil
    z_body= (W_soil * z_soil + W_LCC * z_LCC) / (W_body if W_body else 1)
    Z_ps  = (W_body * z_body + Wp * (H/2.0)) / (W_ps if W_ps else 1)
    # Base resultant term and UPDATED ME height
    N_ps = W_ps * math.cos(rad(alpha)) - KH * W_ps * math.sin(rad(alpha)) + P_ps * math.sin(rad(alpha))
    h_ps_ME = (g_ps * N_ps - W_ps * x_ps + KH * W_ps * Z_ps) / (P_ps if abs(P_ps) > 1e-12 else float('nan'))
    # Static height (info)
    e_tot = (W_body * x_body + Wp * (L2/2.0) + Wt * (L2/2.0)) / (W_st if W_st else 1)
    gst = e_tot / math.cos(rad(alpha))
    N_st = W_st * math.cos(rad(alpha)) + P_st * math.sin(rad(alpha))
    h_st = (gst * N_st - W_st * e_tot) / (P_st if abs(P_st) > 1e-12 else float('nan'))
    return dict(alpha=alpha, PA=P_st, h_st=h_st, PAE=P_ps, h_ps=h_ps_ME)

# ---------- Envelope driver and final report ----------

def compute_v08r_noobj(*,
    # geometry & materials
    h1: float, h2: float, h3: float,
    beta_deg: float, phi_deg: float, c_psf: float,
    gamma_soil: float, gamma_lcc: float, gamma_pav: float,
    surcharge_psf: float, kh: float,
    # alpha sweep
    a_min: float=30.0, a_max: float=60.0, da: float=0.01
) -> Dict[str, float]:
    H = h1 + h2 + h3
    acrit = alpha_crit_from_geometry(h1,h2,beta_deg)
    rows = []
    a = a_min
    while a <= a_max + 1e-12:
        if a > acrit:
            rows.append(eval_regimeA(a,beta_deg,phi_deg,c_psf,h1,h2,h3,gamma_soil,gamma_lcc,gamma_pav,surcharge_psf,kh))
        else:
            rows.append(eval_regimeB(a,beta_deg,phi_deg,c_psf,h1,h2,h3,gamma_soil,gamma_lcc,gamma_pav,surcharge_psf,kh))
        a += da
    # envelopes
    rows_pos = [r for r in rows if (r['PAE'] is not None and r['PAE']>0)]
    if not rows_pos:
        raise RuntimeError('No positive P_AE found in the sweep range.')
    r_pae = max(rows_pos, key=lambda r: r['PAE'])
    r_pa  = max(rows,     key=lambda r: r['PA']  if (r['PA'] is not None) else -1e30)
    alpha_fail = r_pae['alpha']
    PAE_max    = r_pae['PAE']
    PA_max     = r_pa['PA']
    # returns
    hps_ME = r_pae['h_ps']
    hps_SW = (PA_max * (H/3.0) + 0.6*H * (PAE_max - PA_max)) / PAE_max
    return {
        'alpha_crit_deg': acrit,
        'alpha_failure_deg': alpha_fail,
        'regime_at_alpha_failure': ('A' if alpha_fail>acrit else 'B'),
        'PAE_max_lbft': PAE_max,
        'PA_max_lbft': PA_max,
        'h_ps_ME_ft': hps_ME,
        'h_ps_SW_ft': hps_SW
    }

if __name__ == '__main__':
    # Example only (safe to remove)
    out = compute_v08r_noobj(h1=3.0,h2=35.0,h3=2.0,
                             beta_deg=45.0, phi_deg=34.0, c_psf=0.0,
                             gamma_soil=120.0, gamma_lcc=40.0, gamma_pav=150.0,
                             surcharge_psf=240.0, kh=0.16,
                             a_min=30.0, a_max=60.0, da=0.01)
    for k,v in out.items():
        print(f"{k}: {v}")
