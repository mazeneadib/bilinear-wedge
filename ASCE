"""
================================================================================
SUPPLEMENTARY MATERIAL: PYTHON IMPLEMENTATION
Bilinear Wedge Analysis for Active Earth Pressure on Retaining Walls
with Lightweight Cellular Concrete and Soil Backfill
complete with static and pseudo-static seismic analysis
================================================================================
Authors: [Mazen Adib]
Journal: ASCE Journal of Geotechnical and Geoenvironmental Engineering
Date: Submitted for Publication in January 2026
# -*- coding: utf-8 -*-
"""
Adib_ASCE — Bilinear Wedge Analysis (Horizontal-Angle Convention)
------------------------------------------------------------------
Notation: P_A (static), P_AE (pseudo-static); P_1 and P_1E are wedge-1 components.
This script:
  • Computes geometry and weights for two-regime trial-wedge analysis (Case A/B).
  • Evaluates static (P_A) and pseudo-static (P_AE) thrust resultants acting on back face AO.
  • Plots curves vs. α (degrees from horizontal), exports CSVs.
  • Finds maxima for P_A and P_AE and their controlling α.
  • Includes I-405 style defaults via --use-defaults.
Angles are ALL measured from HORIZONTAL.
Back face where thrusts act is AO (heel plane).
δ_A is floating (user-specified), not tied to φ.
"""
import math
import argparse
from dataclasses import dataclass
from typing import Dict, List, Tuple, Callable
import numpy as np
import matplotlib.pyplot as plt
import csv
# --------------------------
# Inputs (angles from horizontal)
# --------------------------
@dataclass
class Inputs:
    h1: float # soil height at heel (ft)
    h2: float # LCC height (ft)
    h3: float # pavement thickness (ft)
    beta_deg: float # LCC interface inclination β (deg from horizontal)
    deltaA_deg: float # wall-backfill interface friction δ_A (deg from horizontal; acts from wall normal)
    gamma_s: float # soil unit weight (pcf)
    gamma_LCC: float # LCC unit weight (pcf)
    gamma_p: float # pavement unit weight (pcf)
    T_l: float # traffic surcharge (psf)
    c_prime: float # effective cohesion c' (psf)
    phi_deg: float # soil friction angle φ (deg)
    k_h: float # horizontal pseudo-static coefficient
    alpha_min: float # lower bound for trial α (deg from horizontal)
    alpha_max: float # upper bound for trial α (deg from horizontal)
    alpha_step: float # step (deg)
    output_prefix: str
# --------------------------
# Coulomb helpers (horizontal-angle convention)
# --------------------------
def A_h(theta: float, phi: float) -> float:
    """A_h = sinθ - tanφ cosθ"""
    return math.sin(theta) - math.tan(phi) * math.cos(theta)
def B_h(theta: float, phi: float) -> float:
    """B_h = cosθ + tanφ sinθ"""
    return math.cos(theta) + math.tan(phi) * math.sin(theta)
# --------------------------
# Geometry & weights (horizontal angles)
# --------------------------
def geometry_and_weights_h(alpha_deg: float, ip: Inputs) -> Dict:
    """
    Compute geometry, volumes, and weights for given trial α (deg from horizontal).
    Returns a dict with case flag ("A" or "B"), key lengths, weights, and alpha_crit.
    """
    a = math.radians(alpha_deg)
    b = math.radians(ip.beta_deg)
    # Critical angle α_crit (horizontal convention: final expression)
    # α_crit = atan( ((h2 + h1) * tanβ) / h2 )
    alpha_crit_rad = math.atan(((ip.h2 + ip.h1) * math.tan(b)) / ip.h2)
    alpha_crit_h_deg = math.degrees(alpha_crit_rad)
    out = {"alpha_deg": alpha_deg, "alpha_crit_deg": alpha_crit_h_deg}
    # Back face AO total height (for possible moment checks later)
    H_AO = ip.h1 + ip.h2
    out["H_AO"] = H_AO
    if alpha_deg >= alpha_crit_h_deg - 1e-9:  # Case A (Two-wedge); corrected to >=
        # --------------------
        # Case A (Two-wedge)
        # --------------------
        # Vertical distances and horizontal extents (angles from horizontal)
        h_soil = (ip.h1 * math.tan(a)) / (math.tan(a) - math.tan(b))
        h_BC = (ip.h1 + ip.h2) - h_soil
        if h_BC < 0 or h_soil < 0:  # Safeguard for non-physical (should not occur with fix)
            raise ValueError(f"Non-physical geometry at α={alpha_deg}: h_BC={h_BC}, h_soil={h_soil}")
        L1 = h_BC / math.tan(b) # = h_BC * cotβ
        L_BO = L1 / math.cos(b) # plane length along β
        L2 = ip.h2 / math.tan(b) - L1 # = h2*cotβ - L1
        L_AB = h_soil / math.sin(a) # trial plane length along α
        # Volumes & weights (per ft width)
        V_LCC_1 = 0.5 * L1 * h_BC
        W_LCC_1 = ip.gamma_LCC * V_LCC_1
        W_p_1 = ip.gamma_p * ip.h3 * L1
        W_t_1 = ip.T_l * L1
        W1_total = W_LCC_1 + W_p_1 + W_t_1
        W1s = W_LCC_1 + W_p_1 # excludes traffic
        V_w2 = 0.5 * (ip.h2 + ip.h1 + h_BC) * L2
        V_LCC_2 = 0.5 * (ip.h2 + h_BC) * L2
        V_soil_2 = V_w2 - V_LCC_2
        W_LCC_2 = ip.gamma_LCC * V_LCC_2
        W_soil_2 = ip.gamma_s * V_soil_2
        W_p_2 = ip.gamma_p * ip.h3 * L2
        W_t_2 = ip.T_l * L2
        W2_total = W_LCC_2 + W_soil_2 + W_p_2 + W_t_2
        W2s = W_LCC_2 + W_soil_2 + W_p_2
        out.update({
            "case": "A",
            "h_soil": h_soil, "h_BC": h_BC,
            "L1": L1, "L2": L2, "L_BO": L_BO, "L_AB": L_AB,
            "W1_total": W1_total, "W2_total": W2_total,
            "W1s": W1s, "W2s": W2s,
        })
    else:  # Case B (Single-wedge)
        # --------------------
        # Case B (Single-wedge)
        # --------------------
        L2 = (ip.h2 + ip.h1) / math.tan(a) # = (h2+h1)*cotα
        L_AB = (ip.h1 + ip.h2) / math.sin(a)
        V_LCC = 0.5 * ip.h2**2 / math.tan(b) # = 0.5*h2^2*cotβ
        V_total = 0.5 * (ip.h2 + ip.h1)**2 / math.tan(a)
        V_soil = V_total - V_LCC
        W_LCC_2 = ip.gamma_LCC * V_LCC
        W_soil_2 = ip.gamma_s * V_soil
        W_p_2 = ip.gamma_p * ip.h3 * L2
        W_t_2 = ip.T_l * L2
        W2_total = W_LCC_2 + W_soil_2 + W_p_2 + W_t_2
        W2s = W_LCC_2 + W_soil_2 + W_p_2
        out.update({
            "case": "B",
            "L2": L2, "L_AB": L_AB,
            "W1_total": 0.0, "W2_total": W2_total,
            "W1s": 0.0, "W2s": W2s,
        })
    return out
# --------------------------
# Single-interface thrust (horizontal angles)
# --------------------------
def thrust_single_interface_h(W_total: float, c_prime: float, L_plane: float,
                              theta_h: float, delta_h: float, phi_h: float,
                              Hs: float = 0.0) -> float:
    """
    Closed-form interface thrust P(θ) for horizontal-angle convention.
    """
    Ah = A_h(theta_h, phi_h)
    Bh = B_h(theta_h, phi_h)
    eps = 1e-12
    if abs(Ah) < eps:
        raise ValueError("A_h(θ,φ) ≈ 0 (θ ≈ φ). Adjust trial angles or φ.")
    num = W_total - c_prime * L_plane * (math.cos(theta_h) + (math.sin(theta_h) * Bh) / Ah) + (Bh / Ah) * Hs
    den = math.sin(delta_h) + (math.cos(delta_h) * Bh) / Ah
    return num / den
# --------------------------
# P_A (static) and P_AE (pseudo-static)
# --------------------------
def compute_P_A(alpha_deg: float, ip: Inputs) -> Dict:
    """
    Returns dict: {'P_A': value, 'alpha_deg':..., 'case':..., 'alpha_crit_deg':...}
    """
    a = math.radians(alpha_deg)
    b = math.radians(ip.beta_deg)
    dA = math.radians(ip.deltaA_deg)
    phi = math.radians(ip.phi_deg)
    g = geometry_and_weights_h(alpha_deg, ip)
    out = {"alpha_deg": alpha_deg, "case": g["case"], "alpha_crit_deg": g["alpha_crit_deg"]}
    if g["case"] == "A":
        P1 = thrust_single_interface_h(g["W1_total"], ip.c_prime, g["L_BO"], b, dA, phi, Hs=0.0)
        PA_c = thrust_single_interface_h(g["W2_total"], ip.c_prime, g["L_AB"], a, dA, phi, Hs=0.0)
        out["P_A"] = P1 + PA_c
    else:
        out["P_A"] = thrust_single_interface_h(g["W2_total"], ip.c_prime, g["L_AB"], a, dA, phi, Hs=0.0)
    return out
def compute_P_AE(alpha_deg: float, ip: Inputs) -> Dict:
    """
    Returns dict: {'P_AE': value, 'alpha_deg':..., 'case':..., 'alpha_crit_deg':...}
    """
    a = math.radians(alpha_deg)
    b = math.radians(ip.beta_deg)
    dA = math.radians(ip.deltaA_deg)
    phi = math.radians(ip.phi_deg)
    g = geometry_and_weights_h(alpha_deg, ip)
    out = {"alpha_deg": alpha_deg, "case": g["case"], "alpha_crit_deg": g["alpha_crit_deg"]}
    if g["case"] == "A":
        H1s = ip.k_h * g["W1s"]
        H2s = ip.k_h * g["W2s"]
        P1E = thrust_single_interface_h(g["W1_total"], ip.c_prime, g["L_BO"], b, dA, phi, Hs=H1s)
        PAE_c = thrust_single_interface_h(g["W2_total"], ip.c_prime, g["L_AB"], a, dA, phi, Hs=H2s)
        out["P_AE"] = P1E + PAE_c
    else:
        H2s = ip.k_h * g["W2s"]
        out["P_AE"] = thrust_single_interface_h(g["W2_total"], ip.c_prime, g["L_AB"], a, dA, phi, Hs=H2s)
    return out
# --------------------------
# Maxima search (grid + golden-section refinement)
# --------------------------
def golden_section_max(f: Callable[[float], float], a: float, b: float,
                       tol: float = 1e-3, max_iter: int = 200) -> Tuple[float, float]:
    """
    Golden-section search for maximum of unimodal f on [a, b] (angles in degrees).
    Returns (x_star, f_star).
    """
    phi = (math.sqrt(5) - 1.0) / 2.0 # ~0.618
    c = b - phi * (b - a)
    d = a + phi * (b - a)
    fc = f(c)
    fd = f(d)
    for _ in range(max_iter):
        if abs(b - a) < tol:
            break
        if fc < fd:
            a = c
            c = d
            fc = fd
            d = a + phi * (b - a)
            fd = f(d)
        else:
            b = d
            d = c
            fd = fc
            c = b - phi * (b - a)
            fc = f(c)
    x_star = 0.5 * (a + b)
    f_star = f(x_star)
    return float(x_star), float(f_star)
def find_max_thrusts(ip: Inputs, use_golden: bool = True,
                     grid_step_deg: float = 1.0, refine_halfwidth_deg: float = 3.0) -> Dict:
    """
    Returns controlling α and maxima for P_A and P_AE + coarse-grid curves.
    """
    alpha_safe_max = min(ip.alpha_max, (90.0 - ip.phi_deg) - 0.5)
    alpha_min = ip.alpha_min
    alpha_grid = np.arange(alpha_min, alpha_safe_max + 1e-9, grid_step_deg)
    alpha_grid = np.round(alpha_grid, 3)
    def P_A_of_alpha(a_deg: float) -> float:
        return compute_P_A(float(a_deg), ip)['P_A']
    def P_AE_of_alpha(a_deg: float) -> float:
        return compute_P_AE(float(a_deg), ip)['P_AE']
    P_A_curve = np.array([P_A_of_alpha(a) for a in alpha_grid], dtype=float)
    P_AE_curve = np.array([P_AE_of_alpha(a) for a in alpha_grid], dtype=float)
    # Coarse maxima (grid)
    i_star_A = int(np.argmax(P_A_curve))
    i_star_AE = int(np.argmax(P_AE_curve))
    alpha_star_A_coarse = float(alpha_grid[i_star_A])
    alpha_star_AE_coarse = float(alpha_grid[i_star_AE])
    P_A_star_coarse = float(P_A_curve[i_star_A])
    P_AE_star_coarse = float(P_AE_curve[i_star_AE])
    # Optional golden-section refinement near coarse maxima
    if use_golden:
        aL = max(alpha_min, alpha_star_A_coarse - refine_halfwidth_deg)
        aR = min(alpha_safe_max, alpha_star_A_coarse + refine_halfwidth_deg)
        aL2 = max(alpha_min, alpha_star_AE_coarse - refine_halfwidth_deg)
        aR2 = min(alpha_safe_max, alpha_star_AE_coarse + refine_halfwidth_deg)
        alpha_star_A, P_A_star = golden_section_max(P_A_of_alpha, aL, aR)
        alpha_star_AE, P_AE_star = golden_section_max(P_AE_of_alpha, aL2, aR2)
    else:
        alpha_star_A, P_A_star = alpha_star_A_coarse, P_A_star_coarse
        alpha_star_AE, P_AE_star = alpha_star_AE_coarse, P_AE_star_coarse
    return {
        "alpha_grid_deg": alpha_grid,
        "P_A_curve": P_A_curve,
        "P_AE_curve": P_AE_curve,
        "alpha_star_P_A_deg": alpha_star_A,
        "P_A_star": P_A_star,
        "alpha_star_P_AE_deg": alpha_star_AE,
        "P_AE_star": P_AE_star
    }
# --------------------------
# Plotting & CSV export
# --------------------------
def _params_text(ip: Inputs) -> str:
    return (
        f"h1={ip.h1} ft, h2={ip.h2} ft, h3={ip.h3} ft\n"
        f"β={ip.beta_deg}°, δ_A={ip.deltaA_deg}°, φ={ip.phi_deg}°\n"
        f"γ_s={ip.gamma_s} pcf, γ_LCC={ip.gamma_LCC} pcf, γ_p={ip.gamma_p} pcf\n"
        f"T_l={ip.T_l} psf, c'={ip.c_prime} psf, k_h={ip.k_h}\n"
        f"α range=({ip.alpha_min}°, {ip.alpha_max}°), step={ip.alpha_step}°"
    )
def _plot_with_alpha_crit(ax, alpha_crit_deg: float):
    ax.axvline(alpha_crit_deg, color='g', linestyle='--', linewidth=1.5,
               label=f"$\\alpha_\\mathrm{{crit}}$ = {alpha_crit_deg:.2f}°")
def plot_curves(alphas: np.ndarray, P_A: np.ndarray, P_AE: np.ndarray,
                ip: Inputs, alpha_crit_deg: float, prefix: str = "PA"):
    text = _params_text(ip)
    # Static
    fig1, ax1 = plt.subplots(figsize=(10, 6))
    ax1.plot(alphas, P_A, 'b-', lw=2, label='$P_A$ (static)')
    i1 = int(np.argmax(P_A))
    ax1.plot(alphas[i1], P_A[i1], 'ro', ms=8,
             label=f"Max: α={alphas[i1]:.2f}°, $P_A$={P_A[i1]:.0f}")
    _plot_with_alpha_crit(ax1, alpha_crit_deg)
    ax1.set_xlabel('Trial angle α (degrees from horizontal)')
    ax1.set_ylabel('Lateral thrust $P_A$ (lb/ft)')
    ax1.set_title('$P_A(\\alpha)$ — Static')
    ax1.grid(True, alpha=0.3)
    ax1.legend(loc='best')
    ax1.text(0.02, 0.02, text, transform=ax1.transAxes, fontsize=9,
             bbox=dict(facecolor='white', alpha=0.8, edgecolor='gray'))
    fig1.tight_layout()
    fig1.savefig(f'{prefix}_static.png', dpi=300, bbox_inches='tight')
    # Pseudo-static
    fig2, ax2 = plt.subplots(figsize=(10, 6))
    ax2.plot(alphas, P_AE, 'r--', lw=2, label='$P_{AE}$ (pseudo-static)')
    i2 = int(np.argmax(P_AE))
    ax2.plot(alphas[i2], P_AE[i2], 'ko', ms=8,
             label=f"Max: α={alphas[i2]:.2f}°, $P_{{AE}}$={P_AE[i2]:.0f}")
    _plot_with_alpha_crit(ax2, alpha_crit_deg)
    ax2.set_xlabel('Trial angle α (degrees from horizontal)')
    ax2.set_ylabel('Lateral thrust $P_{AE}$ (lb/ft)')
    ax2.set_title('$P_{AE}(\\alpha)$ — Pseudo-static')
    ax2.grid(True, alpha=0.3)
    ax2.legend(loc='best')
    ax2.text(0.02, 0.02, text, transform=ax2.transAxes, fontsize=9,
             bbox=dict(facecolor='white', alpha=0.8, edgecolor='gray'))
    fig2.tight_layout()
    fig2.savefig(f'{prefix}_pseudo_static.png', dpi=300, bbox_inches='tight')
    # Overlay
    fig3, ax3 = plt.subplots(figsize=(10, 6))
    ax3.plot(alphas, P_A, 'b-', lw=2, label='$P_A$ (static)')
    ax3.plot(alphas, P_AE, 'r--', lw=2, label='$P_{AE}$ (pseudo-static)')
    _plot_with_alpha_crit(ax3, alpha_crit_deg)
    ax3.set_xlabel('Trial angle α (degrees from horizontal)')
    ax3.set_ylabel('Lateral thrust (lb/ft)')
    ax3.set_title('$P_A$ vs $P_{AE}$')
    ax3.grid(True, alpha=0.3)
    ax3.legend(loc='best')
    ax3.text(0.02, 0.02, text, transform=ax3.transAxes, fontsize=9,
             bbox=dict(facecolor='white', alpha=0.8, edgecolor='gray'))
    fig3.tight_layout()
    fig3.savefig(f'{prefix}_overlay.png', dpi=300, bbox_inches='tight')
    plt.close('all')
def export_csv(alphas: np.ndarray, P_A: np.ndarray, P_AE: np.ndarray,
               cases: List[str], alpha_crit_deg: float, prefix: str):
    # Static
    with open(f'{prefix}_static_curve.csv', 'w', newline='') as f:
        w = csv.writer(f)
        w.writerow(['alpha_deg', 'case', 'P_A', 'alpha_crit_deg'])
        for a, c, e in zip(alphas, cases, P_A):
            w.writerow([f"{a:.3f}", c, f"{e:.6f}", f"{alpha_crit_deg:.6f}"])
    # Pseudo-static
    with open(f'{prefix}_pseudostatic_curve.csv', 'w', newline='') as f:
        w = csv.writer(f)
        w.writerow(['alpha_deg', 'case', 'P_AE', 'alpha_crit_deg'])
        for a, c, e in zip(alphas, cases, P_AE):
            w.writerow([f"{a:.3f}", c, f"{e:.6f}", f"{alpha_crit_deg:.6f}"])
# --------------------------
# CLI / input validation
# --------------------------
def _range_check(name: str, val: float, lo: float, hi: float, inclusive_hi: bool = False):
    if inclusive_hi: ok = (lo <= val <= hi)
    else: ok = (lo <= val < hi)
    if not ok:
        raise argparse.ArgumentTypeError(f"{name} must be in [{lo}, {hi}{']' if inclusive_hi else ')'}; got {val}")
    return val
def angle_0_90(name: str):
    def _f(x: str):
        v = float(x)
        return _range_check(name, v, 0.0, 90.0, inclusive_hi=False)
    return _f
def positive(name: str, allow_zero: bool = False):
    def _f(x: str):
        v = float(x)
        if allow_zero:
            if v < 0:
                raise argparse.ArgumentTypeError(f"{name} must be ≥ 0; got {v}")
        else:
            if v <= 0:
                raise argparse.ArgumentTypeError(f"{name} must be > 0; got {v}")
        return v
    return _f
def get_inputs_from_user() -> Inputs:
    p = argparse.ArgumentParser(description="Adib_ASCE: P_A and P_AE (horizontal-angle convention)")
    p.add_argument('--h1', type=positive('h1', allow_zero=False), help='Soil height at heel (ft) > 0')
    p.add_argument('--h2', type=positive('h2', allow_zero=False), help='LCC height (ft) > 0')
    p.add_argument('--h3', type=positive('h3', allow_zero=True), help='Pavement thickness (ft) ≥ 0')
    p.add_argument('--beta', dest='beta_deg', type=angle_0_90('beta'), help='LCC/soil interface β (deg from horizontal) in [0, 90)')
    p.add_argument('--deltaA', dest='deltaA_deg', type=angle_0_90('deltaA'), help='Wall-backfill friction δ_A (deg from horizontal) in [0, 90)')
    p.add_argument('--gamma_s', type=positive('gamma_s', allow_zero=False), help='Soil unit weight (pcf) > 0')
    p.add_argument('--gamma_LCC', type=positive('gamma_LCC', allow_zero=False), help='LCC unit weight (pcf) > 0')
    p.add_argument('--gamma_p', type=positive('gamma_p', allow_zero=False), help='Pavement unit weight (pcf) > 0')
    p.add_argument('--T_l', type=positive('T_l', allow_zero=True), help='Traffic surcharge (psf) ≥ 0')
    p.add_argument('--c_prime', type=positive('c_prime', allow_zero=True), help="Effective cohesion c' (psf) ≥ 0")
    p.add_argument('--phi', dest='phi_deg', type=angle_0_90('phi'), help='Soil friction angle φ (deg) in [0, 90)')
    p.add_argument('--k_h', type=positive('k_h', allow_zero=True), help='Horizontal pseudo-static coefficient k_h ≥ 0')
    p.add_argument('--alpha_min', type=angle_0_90('alpha_min'), help='Lower bound for α (deg from horizontal) in [0, 90)')
    p.add_argument('--alpha_max', type=angle_0_90('alpha_max'), help='Upper bound for α (deg from horizontal) and < 90-φ')
    p.add_argument('--alpha_step', type=positive('alpha_step', allow_zero=False), default=1.0,
                   help='Step for α in degrees (recommended 1.0)')
    p.add_argument('--output_prefix', type=str, default='PA', help='Prefix for output files (PNG/CSV)')
    p.add_argument('--use-defaults', action='store_true', help='Use I-405 style defaults')
    args = p.parse_args()
    if args.use_defaults:
        # I-405 style defaults (angles from horizontal)
        return Inputs(
            h1=3.0, h2=25.0, h3=2.0,
            beta_deg=45.0, deltaA_deg=0.0, # δ_A kept floating; 0° is common for smooth contact assumption
            gamma_s=120.0, gamma_LCC=40.0, gamma_p=150.0,
            T_l=0.0, c_prime=0.0, phi_deg=34.0,
            k_h=0.16, alpha_min=20.0, alpha_max=60.0, alpha_step=1.0,
            output_prefix='I405'
        )
    # Interactive prompts for any missing args (optional)
    def prompt(name, default=None, caster=float):
        val = getattr(args, name, None)
        if val is not None:
            return val
        s = input(f"Enter {name.replace('_',' ')}" + (f" [default {default}]" if default is not None else "") + ": ").strip()
        if s == '' and default is not None:
            return default
        return caster(s)
    ip = Inputs(
        h1=args.h1 if args.h1 is not None else prompt('h1', 3.0),
        h2=args.h2 if args.h2 is not None else prompt('h2', 25.0),
        h3=args.h3 if args.h3 is not None else prompt('h3', 2.0),
        beta_deg=args.beta_deg if args.beta_deg is not None else prompt('beta_deg', 45.0),
        deltaA_deg=args.deltaA_deg if args.deltaA_deg is not None else prompt('deltaA_deg', 0.0),
        gamma_s=args.gamma_s if args.gamma_s is not None else prompt('gamma_s', 120.0),
        gamma_LCC=args.gamma_LCC if args.gamma_LCC is not None else prompt('gamma_LCC', 40.0),
        gamma_p=args.gamma_p if args.gamma_p is not None else prompt('gamma_p', 150.0),
        T_l=args.T_l if args.T_l is not None else prompt('T_l', 0.0),
        c_prime=args.c_prime if args.c_prime is not None else prompt('c_prime', 0.0),
        phi_deg=args.phi_deg if args.phi_deg is not None else prompt('phi_deg', 34.0),
        k_h=args.k_h if args.k_h is not None else prompt('k_h', 0.16),
        alpha_min=args.alpha_min if args.alpha_min is not None else prompt('alpha_min', 20.0),
        alpha_max=args.alpha_max if args.alpha_max is not None else prompt('alpha_max', 60.0),
        alpha_step=args.alpha_step,
        output_prefix=args.output_prefix
    )
    # Post-hoc validation: α range and singularity guard
    alpha_safe_max = min(ip.alpha_max, (90.0 - ip.phi_deg) - 0.5)
    if ip.alpha_min >= alpha_safe_max:
        raise argparse.ArgumentTypeError(
            f"alpha_min must be < min(alpha_max, 90°-φ-0.5°); got alpha_min={ip.alpha_min}, "
            f"alpha_max={ip.alpha_max}, φ={ip.phi_deg}"
        )
    if ip.alpha_step < 0.5 or ip.alpha_step > 10.0:
        raise argparse.ArgumentTypeError("alpha_step should be in [0.5, 10] for reasonable resolution.")
    return ip
# --------------------------
# Main workflow
# --------------------------
def main():
    ip = get_inputs_from_user()
    # Compute α_crit in horizontal convention for info display (using the final expression)
    alpha_crit_deg = math.degrees(math.atan(((ip.h2 + ip.h1) * math.tan(math.radians(ip.beta_deg))) / ip.h2))
    alpha_safe_max = min(ip.alpha_max, (90.0 - ip.phi_deg) - 0.5)
    # α grid at requested increments
    alphas = np.arange(ip.alpha_min, alpha_safe_max + 1e-9, ip.alpha_step)
    alphas = np.round(alphas, 3)
    # Compute curves
    P_A = []
    P_AE = []
    cases = []
    for a in alphas:
        rs = compute_P_A(float(a), ip); P_A.append(rs['P_A']); cases.append(rs['case'])
        rp = compute_P_AE(float(a), ip); P_AE.append(rp['P_AE'])
    P_A = np.array(P_A); P_AE = np.array(P_AE)
    # Plot
    plot_curves(alphas, P_A, P_AE, ip, alpha_crit_deg, prefix=ip.output_prefix)
    # CSV export
    export_csv(alphas, P_A, P_AE, cases, alpha_crit_deg, prefix=ip.output_prefix)
    # Maxima (grid + golden-section refinement)
    res_max = find_max_thrusts(ip, use_golden=True, grid_step_deg=ip.alpha_step, refine_halfwidth_deg=3.0)
    print("\nWORKFLOW OVERVIEW")
    print(" Step 1 — Geometry & weights: horizontal-angle convention for α, β, δ_A.")
    print(" Step 2 — Thrust equations: Coulomb A_h(θ,φ), B_h(θ,φ) for P_A and P_AE.")
    print(" Step 3 — Scan α-range: curves at requested increments; find maxima.")
    print(" Step 4 — Plot & Export: static/pseudo-static PNGs and CSVs.")
    print(" Step 5 — Summary: controlling α and maxima for both cases.\n")
    print("✓ Inputs used:")
    print(_params_text(ip))
    print("\n✓ Controlling failure surfaces (horizontal-angle convention):")
    print(f" - Static (P_A): α* = {res_max['alpha_star_P_A_deg']:.2f}°, P_A* = {res_max['P_A_star']:.3f} lb/ft")
    print(f" - Pseudo-static (P_AE): α* = {res_max['alpha_star_P_AE_deg']:.2f}°, P_AE* = {res_max['P_AE_star']:.3f} lb/ft")
    # Save maxima summary
    with open(f"{ip.output_prefix}_maxima_summary.csv", "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["case", "alpha_star_deg", "P_star_lb_per_ft"])
        w.writerow(["static_P_A", f"{res_max['alpha_star_P_A_deg']:.6f}", f"{res_max['P_A_star']:.6f}"])
        w.writerow(["pseudo_static_P_AE", f"{res_max['alpha_star_P_AE_deg']:.6f}", f"{res_max['P_AE_star']:.6f}"])
    print("\n✓ Outputs saved:")
    print(f" - {ip.output_prefix}_static.png")
    print(f" - {ip.output_prefix}_pseudo_static.png")
    print(f" - {ip.output_prefix}_overlay.png")
    print(f" - {ip.output_prefix}_static_curve.csv")
    print(f" - {ip.output_prefix}_pseudostatic_curve.csv")
    print(f" - {ip.output_prefix}_maxima_summary.csv\n")
    # Optional: basic I-405 calculation report if defaults are used
    if ip.output_prefix.lower() == 'i405':
        print("I-405 example run complete (angles from horizontal).")
if __name__ == '__main__':
    main()
