
# -*- coding: utf-8 -*-
"""
adib_active_wedge.py
Final implementation for Cases A & B (δ_A=0) with:
 - Case A static: solves z_p1 from Wedge 1 about B; adds P1*(z_p1 + h_soil) into wall moment for h_st
 - Case A pseudo-static: excludes pavement/traffic; admissibility on Wedge 1
 - Case B (static & pseudo): single wedge formulas
Author: Prepared for Mazen Adib (Jan 21, 2026)
"""

import math
from dataclasses import dataclass
from typing import List, Tuple, Dict

# -------------------------
# Global constants
# -------------------------
h1 = 3.0       # ft
h2 = 25.0      # ft
H  = h1 + h2   # ft
h3 = 3.0       # ft

G_SOIL = 125.0  # pcf
G_LCC  = 40.0   # pcf
G_PAV  = 150.0  # pcf
T_SUR  = 240.0  # psf

# Search grid for alpha (deg)
ALPHA_MIN = 15.0
ALPHA_MAX = 75.0
ALPHA_DA  = 0.5

rad = math.radians
def cot(r: float) -> float:
    return math.cos(r) / math.sin(r)

def alpha_crit(beta_deg: float) -> float:
    b = rad(beta_deg)
    return math.degrees(math.atan((H * math.tan(b)) / h2))

def thrust_eq21(theta_deg: float, W: float, phi_deg: float, kh: float, c_prime: float, Lc: float) -> float:
    """Eq. (21), δ_A=0."""
    th = rad(theta_deg)
    ph = rad(phi_deg)
    denom = math.cos(th) + math.sin(th) * math.tan(ph)
    num = W * (math.sin(th) - math.cos(th) * math.tan(ph) + kh * (math.cos(th) + math.sin(th) * math.tan(ph))) - c_prime * Lc
    return num / denom

def poly_area_centroid(vertices: List[Tuple[float, float]]) -> Tuple[float, float, float]:
    """Absolute area and centroid of polygon by shoelace."""
    A2 = 0.0; Cx = 0.0; Cy = 0.0
    n = len(vertices)
    for i in range(n):
        x1, y1 = vertices[i]
        x2, y2 = vertices[(i + 1) % n]
        cr = x1 * y2 - y1 * x2
        A2 += cr
        Cx += (x1 + x2) * cr
        Cy += (y1 + y2) * cr
    A = A2 / 2.0
    if abs(A) < 1e-15:
        return 0.0, 0.0, 0.0
    Cx /= (6.0 * A)
    Cy /= (6.0 * A)
    return abs(A), Cx, Cy

# -------------------------
# Case A geometry (per slides)
# -------------------------
@dataclass
class CaseAData:
    alpha: float; beta: float
    h_soil: float; h_BC: float; L1: float; L2: float
    V_soil2: float; xS2: float; zS2: float
    V_LCC2: float;  xL2: float; zL2: float
    V_LCC1: float;  xL1: float; zL1: float
    Wp2: float; Wt2: float; e_p2: float; e_t2: float
    Wp1: float; Wt1: float; e_p1: float; e_t1: float
    W_soil2: float; W_LCC2: float; W2_body: float; W2_static: float
    W_LCC1: float;  W1_static: float
    L_AB: float; L_BO: float

def build_caseA(alpha_deg: float, beta_deg: float) -> CaseAData:
    a = rad(alpha_deg); b = rad(beta_deg)
    h_soil = h1 * math.tan(a) / (math.tan(a) - math.tan(b))
    h_BC = H - h_soil
    L2 = h_soil * cot(a)
    L1 = h_BC * cot(b)
    # polygons
    A_pt = (0.0, 0.0); O_pt = (0.0, h1); Op_pt = (0.0, H); B_pt = (L2, h_soil); C_pt = (L2, H)
    V_soil2, xS2, zS2 = poly_area_centroid([A_pt, O_pt, B_pt])
    V_LCC2,  xL2, zL2 = poly_area_centroid([O_pt, Op_pt, C_pt, B_pt])
    V_LCC1 = 0.5 * L1 * h_BC
    # A-frame centroid for Wedge 1
    xL1 = L2 + L1 / 3.0
    zL1 = h_soil + 2.0 * h_BC / 3.0
    # strips (static)
    Wp2 = G_PAV * h3 * L2; Wt2 = T_SUR * L2; e_p2 = e_t2 = L2 / 2.0
    Wp1 = G_PAV * h3 * L1; Wt1 = T_SUR * L1; e_p1 = e_t1 = L2 + L1 / 2.0
    # weights
    W_soil2 = G_SOIL * V_soil2
    W_LCC2  = G_LCC  * V_LCC2
    W2_body = W_soil2 + W_LCC2
    W2_static = W2_body + Wp2 + Wt2
    W_LCC1 = G_LCC * V_LCC1
    W1_static = W_LCC1 + Wp1 + Wt1
    # contact lengths
    L_AB = h_soil / math.sin(a)
    L_BO = L1 / math.cos(b)
    return CaseAData(alpha_deg, beta_deg, h_soil, h_BC, L1, L2,
                     V_soil2, xS2, zS2, V_LCC2, xL2, zL2,
                     V_LCC1, xL1, zL1,
                     Wp2, Wt2, e_p2, e_t2, Wp1, Wt1, e_p1, e_t1,
                     W_soil2, W_LCC2, W2_body, W2_static, W_LCC1, W1_static,
                     L_AB, L_BO)

# z_p1 from Wedge 1 moments about B (k_h=0)
def zp1_from_wedge1(P1: float, data: CaseAData) -> float:
    a = rad(data.alpha); cosA = math.cos(a)
    sum_eW_B = data.W_LCC1*(data.L1/3.0) + data.Wp1*(data.L1/2.0) + data.Wt1*(data.L1/2.0)
    e1_B = sum_eW_B / data.W1_static if data.W1_static > 0 else 0.0
    g1 = e1_B / cosA if cosA != 0 else 0.0
    N1_st = data.W1_static * cosA + P1 * math.sin(a)
    return (g1 * N1_st - sum_eW_B) / P1

# Case A: static with P1 moment term; pseudo-static (unchanged)
def caseA_static_with_p1(alpha_deg: float, beta_deg: float, phi_deg: float, c_prime: float):
    data = build_caseA(alpha_deg, beta_deg)
    P1 = thrust_eq21(beta_deg, data.W1_static,  phi_deg, 0.0, c_prime, data.L_BO)
    P2 = thrust_eq21(alpha_deg, data.W2_static, phi_deg, 0.0, c_prime, data.L_AB)
    include1 = P1 > 0.0
    P_A = (P1 if include1 else 0.0) + P2
    a = rad(alpha_deg); cosA = math.cos(a); sinA = math.sin(a)
    e2_tot = (data.W_soil2*data.xS2 + data.W_LCC2*data.xL2 + data.Wp2*data.e_p2 + data.Wt2*data.e_t2) / data.W2_static
    e1_tot = (data.W_LCC1*data.xL1 + data.Wp1*data.e_p1 + data.Wt1*data.e_t1) / data.W1_static if data.W1_static > 0 else 0.0
    sumW = data.W2_static + (data.W1_static if include1 else 0.0)
    g_st = (data.W2_static*(e2_tot/cosA) + ((data.W1_static*(e1_tot/cosA)) if include1 else 0.0)) / sumW
    N_st = sumW * cosA + P_A * sinA
    sumWe = data.W2_static*e2_tot + ((data.W1_static*e1_tot) if include1 else 0.0)
    add = 0.0; z_p1 = None
    if include1:
        z_p1 = zp1_from_wedge1(P1, data)
        add   = P1 * (z_p1 + data.h_soil)
    h_st = (g_st * N_st - sumWe + add) / P_A if abs(P_A) > 1e-12 else 0.0
    return data, P1, P2, P_A, h_st, z_p1

def caseA_pseudostatic(alpha_deg: float, beta_deg: float, phi_deg: float, kh: float, c_prime: float):
    data = build_caseA(alpha_deg, beta_deg)
    P1E = thrust_eq21(beta_deg, data.W_LCC1,  phi_deg, kh, c_prime, data.L_BO)
    P2E = thrust_eq21(alpha_deg, data.W2_body, phi_deg, kh, c_prime, data.L_AB)
    include1 = P1E > 0.0
    P_AE = (P1E if include1 else 0.0) + P2E
    a = rad(alpha_deg); cosA = math.cos(a); sinA = math.sin(a)
    W1s = data.W_LCC1; W2s = data.W2_body
    # composite Wedge 2 centroid (body only)
    x2 = (data.W_soil2*data.xS2 + data.W_LCC2*data.xL2) / data.W2_body if data.W2_body > 0 else 0.0
    z2 = (data.W_soil2*data.zS2 + data.W_LCC2*data.zL2) / data.W2_body if data.W2_body > 0 else 0.0
    num = (W2s*cosA + kh*W2s*sinA) * (x2 / cosA)
    den = (W2s*cosA + kh*W2s*sinA)
    if include1:
        num += (W1s*cosA + kh*W1s*sinA) * (data.xL1 / cosA)
        den += (W1s*cosA + kh*W1s*sinA)
    g_ps = num / den if abs(den) > 0.0 else 0.0
    Wsum = W2s + (W1s if include1 else 0.0)
    N_ps = Wsum*cosA - kh*Wsum*sinA + P_AE*sinA
    sum_eW = W2s*x2 + ((W1s*data.xL1) if include1 else 0.0)
    sum_zkW = kh * (W2s*z2 + ((W1s*data.zL1) if include1 else 0.0))
    h_ps = (g_ps * N_ps - sum_eW + sum_zkW) / P_AE if abs(P_AE) > 1e-12 else 0.0
    return data, P_AE, h_ps

# -------------------------
# Case B (single wedge)
# -------------------------
@dataclass
class CaseBData:
    alpha: float; beta: float
    L2: float; V_tot: float; V_LCC: float; V_soil: float
    W_LCC: float; W_soil: float; W_body: float
    x_LCC: float; z_LCC: float; x_soil: float; z_soil: float
    Wp: float; Wt: float; e_p: float; e_t: float
    W_static: float; L_AB: float

def build_caseB(alpha_deg: float, beta_deg: float) -> CaseBData:
    a = rad(alpha_deg); b = rad(beta_deg)
    L2 = H * cot(a)
    V_tot = 0.5 * H * H * cot(a)
    V_LCC = 0.5 * h2 * h2 * cot(b)
    V_soil = V_tot - V_LCC
    W_LCC = G_LCC * V_LCC
    W_soil = G_SOIL * V_soil
    W_body = W_LCC + W_soil
    x_LCC = (1.0/3.0) * h2 * cot(b)
    z_LCC = h1 + (2.0/3.0) * h2
    num_x = (H**3)*(cot(a)**2) - (h2**3)*(cot(b)**2)
    den   = 3.0*((H**2)*cot(a) - (h2**2)*cot(b))
    x_soil = num_x / den
    num_z  = 2.0*(H**3)*cot(a) - (h2**2)*cot(b)*(3.0*h1 + 2.0*h2)
    z_soil = num_z / den
    Wp = G_PAV * h3 * L2
    Wt = T_SUR * L2
    e_p = e_t = L2 / 2.0
    W_static = W_body + Wp + Wt
    L_AB = H / math.sin(a)
    return CaseBData(alpha_deg, beta_deg, L2, V_tot, V_LCC, V_soil,
                     W_LCC, W_soil, W_body, x_LCC, z_LCC, x_soil, z_soil,
                     Wp, Wt, e_p, e_t, W_static, L_AB)

def caseB_static(alpha_deg: float, beta_deg: float, phi_deg: float, c_prime: float):
    data = build_caseB(alpha_deg, beta_deg)
    P_A = thrust_eq21(alpha_deg, data.W_static, phi_deg, 0.0, c_prime, data.L_AB)
    a = rad(alpha_deg); cosA = math.cos(a)
    x_body = (data.W_soil*data.x_soil + data.W_LCC*data.x_LCC) / data.W_body
    e_tot = (data.W_body * x_body + data.Wp * data.e_p + data.Wt * data.e_t) / data.W_static
    g_st = e_tot / cosA
    N_st = data.W_static * cosA + P_A * math.sin(a)
    h_st = (g_st * N_st - data.W_static * e_tot) / P_A if abs(P_A) > 1e-12 else 0.0
    return data, P_A, h_st

def caseB_pseudostatic(alpha_deg: float, beta_deg: float, phi_deg: float, kh: float, c_prime: float):
    data = build_caseB(alpha_deg, beta_deg)
    P_AE = thrust_eq21(alpha_deg, data.W_body, phi_deg, kh, c_prime, data.L_AB)
    a = rad(alpha_deg); cosA = math.cos(a)
    x_body = (data.W_soil*data.x_soil + data.W_LCC*data.x_LCC) / data.W_body
    z_body = (data.W_soil*data.z_soil + data.W_LCC*data.z_LCC) / data.W_body
    g_ps = x_body / cosA
    N_ps = data.W_body * math.cos(a) - kh * data.W_body * math.sin(a) + P_AE * math.sin(a)
    h_ps = (g_ps * N_ps - data.W_body * x_body + kh * data.W_body * z_body) / P_AE if abs(P_AE) > 1e-12 else 0.0
    return data, P_AE, h_ps

# -------------------------
# Evaluators and reporting
# -------------------------
def evaluate_case_A(beta_deg: float, phi_deg: float, c_prime: float, kh: float=0.16) -> Dict:
    acrit = alpha_crit(beta_deg)
    # static (with P1 moment)
    best_st = None
    a = max(ALPHA_MIN, acrit + 1e-6)
    while a <= ALPHA_MAX + 1e-9:
        _, P1, P2, P_A, h_st, z_p1 = caseA_static_with_p1(a, beta_deg, phi_deg, c_prime)
        if (best_st is None) or (P_A > best_st["P_A"]):
            best_st = {"alpha": a, "P_A": P_A, "h_st": h_st, "P1": P1, "z_p1": z_p1}
        a += ALPHA_DA
    # pseudo-static
    best_ps = None
    a = max(ALPHA_MIN, acrit + 1e-6)
    while a <= ALPHA_MAX + 1e-9:
        _, P_AE, h_ps = caseA_pseudostatic(a, beta_deg, phi_deg, kh, c_prime)
        if (best_ps is None) or (P_AE > best_ps["P_AE"]):
            best_ps = {"alpha": a, "P_AE": P_AE, "h_ps": h_ps}
        a += ALPHA_DA
    return {"alpha_crit": acrit, "static": best_st, "pseudo": best_ps}

def evaluate_case_B(beta_deg: float, phi_deg: float, c_prime: float, kh: float=0.16) -> Dict:
    acrit = alpha_crit(beta_deg)
    best_st = None; best_ps = None
    a = ALPHA_MIN
    while a <= min(ALPHA_MAX, acrit) + 1e-9:
        _, P_A, h_st = caseB_static(a, beta_deg, phi_deg, c_prime)
        _, P_AE, h_ps = caseB_pseudostatic(a, beta_deg, phi_deg, kh, c_prime)
        if (best_st is None) or (P_A > best_st["P_A"]): best_st = {"alpha": a, "P_A": P_A, "h_st": h_st}
        if (best_ps is None) or (P_AE > best_ps["P_AE"]): best_ps = {"alpha": a, "P_AE": P_AE, "h_ps": h_ps}
        a += ALPHA_DA
    return {"alpha_crit": acrit, "static": best_st, "pseudo": best_ps}

def emit_latex_table(rows: List[Dict]) -> str:
    lines = []
    lines.append("\\begin{tabular}{llrrrrrr}")
    lines.append("\\toprule")
    lines.append("Case & Regime & $\\alpha^*_\\mathrm{st}$ & $P_A$ & $h_{\\mathrm{st}}$ & $\\alpha^*_\\mathrm{ps}$ & $P_{AE}$ & $h_{\\mathrm{ps}}$ \\\\")
    lines.append("\\midrule")
    for r in rows:
        # Case A row
        lines.append(f"{r['name']} & A & {r['A_static_alpha']:.2f} & {r['A_P_A']:.2f} & {r['A_h_st']:.2f} & "
                     f"{r['A_pseudo_alpha']:.2f} & {r['A_P_AE']:.2f} & {r['A_h_ps']:.2f} \\\\")
        # Case B row
        lines.append(f"{r['name']} & B & {r['B_static_alpha']:.2f} & {r['B_P_A']:.2f} & {r['B_h_st']:.2f} & "
                     f"{r['B_pseudo_alpha']:.2f} & {r['B_P_AE']:.2f} & {r['B_h_ps']:.2f} \\\\")
    lines.append("\\bottomrule")
    lines.append("\\end{tabular}")
    return "\n".join(lines)

if __name__ == "__main__":
    cases = [
        {"name": "Case 1", "beta": 45.0,  "phi": 34.0, "c": 0.0},
        {"name": "Case 2", "beta": 33.69, "phi": 34.0, "c": 0.0},
        {"name": "Case 3", "beta": 33.69, "phi": 30.0, "c": 0.0},
        {"name": "Case 4", "beta": 45.0,  "phi": 34.0, "c": 200.0},
    ]
    rows = []
    for cs in cases:
        resA = evaluate_case_A(cs["beta"], cs["phi"], cs["c"])
        resB = evaluate_case_B(cs["beta"], cs["phi"], cs["c"])
        print(f"\n{cs['name']} (beta={cs['beta']}°, phi={cs['phi']}°, c'={cs['c']} psf)")
        print(f"  Case A: alpha_crit = {resA['alpha_crit']:.4f}°")
        print(f"    STATIC : alpha*={resA['static']['alpha']:.2f}°,  P_A={resA['static']['P_A']:.2f} lb/ft,  h_st={resA['static']['h_st']:.3f} ft")
        print(f"    PSEUDO : alpha*={resA['pseudo']['alpha']:.2f}°,  P_AE={resA['pseudo']['P_AE']:.2f} lb/ft, h_ps={resA['pseudo']['h_ps']:.3f} ft")
        print(f"  Case B: alpha_crit = {resB['alpha_crit']:.4f}°")
        print(f"    STATIC : alpha*={resB['static']['alpha']:.2f}°,  P_A={resB['static']['P_A']:.2f} lb/ft,  h_st={resB['static']['h_st']:.3f} ft")
        print(f"    PSEUDO : alpha*={resB['pseudo']['alpha']:.2f}°,  P_AE={resB['pseudo']['P_AE']:.2f} lb/ft, h_ps={resB['pseudo']['h_ps']:.3f} ft")

        rows.append({
            "name": cs["name"],
            "A_static_alpha": resA["static"]["alpha"], "A_P_A": resA["static"]["P_A"], "A_h_st": resA["static"]["h_st"],
            "A_pseudo_alpha": resA["pseudo"]["alpha"], "A_P_AE": resA["pseudo"]["P_AE"], "A_h_ps": resA["pseudo"]["h_ps"],
            "B_static_alpha": resB["static"]["alpha"], "B_P_A": resB["static"]["P_A"], "B_h_st": resB["static"]["h_st"],
            "B_pseudo_alpha": resB["pseudo"]["alpha"], "B_P_AE": resB["pseudo"]["P_AE"], "B_h_ps": resB["pseudo"]["h_ps"],
        })

    print("\nLaTeX table:")
    print(emit_latex_table(rows))
