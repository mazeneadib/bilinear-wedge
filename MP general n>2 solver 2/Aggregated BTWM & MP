# -*- coding: utf-8 -*-
"""
UNIFIED BTWM (V08R) -> MP (Morgenstern-Price) -> h_st and h_ps
============================================================

What this script does
---------------------
1) Runs your BTWM V08R envelope twice:
   - Static run:       kh = 0.0
       * Uses:  Pa_static = PA_max_lbft
       * Uses:  alpha_static = alpha_failure_deg
   - Pseudo-static run: kh = kh_pseudo
       * Uses:  Pa_pseudo  = PAE_max_lbft
       * Uses:  alpha_pseudo = alpha_failure_deg

2) For each case, builds MP slices using that alpha_failure (note: static/pseudo can differ).
3) MP inner solve (3 unknowns):
       x = (FS, lambda, E0_s),  where E0 = E0_s * Pa
   Residuals (3):
       r = [En, Mtot, Fx_res] = 0
   with moment term using: Ma = Pa * h
4) Outer solve finds h such that FS(h) = 1, producing:
       h_st (static), h_ps (pseudo-static)

Key MP “nuances” implemented per your intent
--------------------------------------------
A) Pavement + surcharge weights in slice W:
   - STATIC: includes pavement + traffic surcharge
   - PSEUDO: includes pavement only (traffic surcharge excluded)

B) Cap-load x location:
   - Pavement and surcharge resultants act at slice mid-width:
       x_cap = x_mid = (x0 + x1)/2

C) Pavement does NOT lift pseudo-static inertia arm:
   - We compute y_inert per slice using ONLY soil + LCC centroid height.
   - But inertia magnitude uses total W (including pavement in pseudo).
   - Inertial moment uses y_inert:
       M_in += - y_inert * (-kh * W_total)

Bounds
------
FS in [0.95, 1.05]
lambda in (0, 0.8]
E0_s in [-50, 50]  (dimensionless scaling relative to Pa)

Dependencies
------------
- numpy
- scipy (for least_squares)
"""

from __future__ import annotations
import math
import numpy as np
from typing import Dict, List, Optional, Tuple


# =============================================================================
# BTWM V08R (your code, kept essentially intact)
# =============================================================================

rad = math.radians

def thrust_P(W: float, theta_deg: float, phi_deg: float, c_prime: float, Lc: float, kh_val: float) -> float:
    s = math.sin(rad(theta_deg)); c = math.cos(rad(theta_deg)); tphi = math.tan(rad(phi_deg))
    den = c + s * tphi
    if abs(den) < 1e-12: den = 1e-12
    return (W * ((s - c * tphi) + kh_val * (c + s * tphi)) - c_prime * Lc) / den

def alpha_crit_from_geometry(h1: float, h2: float, beta_deg: float) -> float:
    Hs = h1 + h2
    beta = rad(beta_deg)
    return math.degrees(math.atan((Hs * math.tan(beta)) / h2))

# ---------- Regime A geometry & wedge-2 areas/centroids ----------

def regimeA_geometry(alpha: float, beta: float, h1: float, h2: float):
    ta = math.tan(rad(alpha)); tb = math.tan(rad(beta)); H = h1 + h2
    if abs(ta - tb) < 1e-12: ta += 1e-12
    h_soil = h1 * ta / (ta - tb)
    h_BC   = H - h_soil
    L1     = h_BC / math.tan(rad(beta))
    LBO    = L1 / math.cos(rad(beta))
    L2     = h2 / math.tan(rad(beta)) - L1
    LAB    = h_soil / math.sin(rad(alpha))
    return H, h_soil, h_BC, L1, LBO, L2, LAB

def wedge2_regimeA_areas_centroids(alpha: float, beta: float, h1: float, h2: float):
    H, h_soil, h_BC, L1, LBO, L2, LAB = regimeA_geometry(alpha, beta, h1, h2)
    V_soil2 = 0.5 * h1 * L2
    x_S2 = L2 / 3.0
    z_S2 = (h1 + h_soil) / 3.0
    V_LCC2 = L2 * (H - 0.5 * (h1 + h_soil))
    denom = (2*H - h1 - h_soil)
    if abs(denom) < 1e-12:
        x_L2 = L2 / 2.0; z_L2 = (H + h1) / 2.0
    else:
        x_L2 = L2 * (3*H - h1 - 2*h_soil) / (3 * denom)
        z_L2 = (H*H - (h_soil*h_soil + h1*h1 + h1*h_soil)/3.0) / denom
    return dict(H=H, h_soil=h_soil, h_BC=h_BC, L1=L1, LBO=LBO, L2=L2, LAB=LAB,
                V_soil2=V_soil2, x_S2=x_S2, z_S2=z_S2, V_LCC2=V_LCC2, x_L2=x_L2, z_L2=z_L2)

# ---------- Regime B geometry ----------

def regimeB_geometry(alpha: float, beta: float, h1: float, h2: float):
    H = h1 + h2
    L2 = H / math.tan(rad(alpha))
    LAB = H / math.sin(rad(alpha))
    V_LCC = 0.5 * h2 * h2 / math.tan(rad(beta))
    V_tot = 0.5 * H * H / math.tan(rad(alpha))
    V_soil = V_tot - V_LCC
    return H, L2, LAB, V_LCC, V_soil

# ---------- Evaluate Regime A at alpha ----------

def eval_regimeA(alpha: float, beta: float, phi: float, c_prime: float,
                 h1: float, h2: float, h3: float,
                 gam_soil: float, gam_lcc: float, gam_pav: float, surch: float,
                 KH: float) -> Dict:
    g = wedge2_regimeA_areas_centroids(alpha, beta, h1, h2)
    H, h_soil, h_BC, L1, LBO, L2, LAB = g['H'], g['h_soil'], g['h_BC'], g['L1'], g['LBO'], g['L2'], g['LAB']
    # Weights
    W_soil2 = gam_soil * g['V_soil2']; W_LCC2 = gam_lcc * g['V_LCC2']
    Wp2 = gam_pav * h3 * L2; Wt2 = surch * L2
    W2_body = W_soil2 + W_LCC2
    W2_st = W2_body + Wp2 + Wt2            # static body includes surcharge
    W2_ps = W2_body + Wp2                  # pseudo-static body excludes surcharge
    # Pseudo centroid arms
    x2_ps = (W2_body*((W_soil2*g['x_S2'] + W_LCC2*g['x_L2'])/(W2_body if W2_body else 1)) + Wp2*(L2/2.0))/(W2_ps if W2_ps else 1)
    z2_ps = (W2_body*((W_soil2*g['z_S2'] + W_LCC2*g['z_L2'])/(W2_body if W2_body else 1)) + Wp2*(H/2.0))/(W2_ps if W2_ps else 1)
    g_ps = x2_ps / math.cos(rad(alpha))
    # Wedge 1
    V_LCC1 = 0.5 * L1 * h_BC; W_LCC1 = gam_lcc * V_LCC1
    Wp1 = gam_pav * h3 * L1; Wt1 = surch * L1
    W1_st = W_LCC1 + Wp1 + Wt1
    W1_ps = W_LCC1 + Wp1
    # Thrusts
    P1    = thrust_P(W1_st, beta,  phi, c_prime, LBO, 0.0)
    P1_ps = thrust_P(W1_ps, beta,  phi, c_prime, LBO, KH)
    P2    = thrust_P(W2_st, alpha, phi, c_prime, LAB, 0.0)
    P2_ps = thrust_P(W2_ps, alpha, phi, c_prime, LAB, KH)
    include1S = (P1    > 0.0)
    include1E = (P1_ps > 0.0)
    PA  = (P1 if include1S else 0.0) + P2
    PAE = (P1_ps if include1E else 0.0) + P2_ps
    # Moment-equilibrium pseudo height (Regime A)
    N_ps = W2_ps * math.cos(rad(alpha)) - KH * W2_ps * math.sin(rad(alpha)) + P2_ps * math.sin(rad(alpha))
    z1B_ps = (W_LCC1*(h_BC*2.0/3.0) + Wp1*(h_BC/2.0)) / (W1_ps if W1_ps else 1)
    if not include1E:
        M1_ps = 0.0
    else:
        if P1 <= 0.0:
            zp1_ps = z1B_ps
        else:
            S1 = W_LCC1*(L1/3.0) + Wp1*(L1/2.0)
            e1B_ps = S1 / (W1_ps if W1_ps else 1)
            g1_ps = e1B_ps / math.cos(rad(beta))
            N1_ps = W1_ps * math.cos(rad(beta)) - KH * W1_ps * math.sin(rad(beta)) + P1_ps * math.sin(rad(beta))
            zp1_ps = (g1_ps * N1_ps - S1 + KH * W1_ps * z1B_ps) / (P1_ps if P1_ps else 1)
            zp1_ps = max(0.0, min(h_BC, zp1_ps))
        M1_ps = (P1_ps if include1E else 0.0) * (zp1_ps + h_soil)
    h_ps_ME = (g_ps * N_ps - W2_ps * x2_ps + KH * W2_ps * z2_ps + M1_ps) / (PAE if abs(PAE) > 1e-12 else float('nan'))
    # Static height (info only)
    x2_tot = (W_soil2*g['x_S2'] + W_LCC2*g['x_L2'] + Wp2*(L2/2.0) + Wt2*(L2/2.0)) / (W2_st if W2_st else 1)
    gst = x2_tot / math.cos(rad(alpha))
    N_st = W2_st * math.cos(rad(alpha)) + P2 * math.sin(rad(alpha))
    M1_st = 0.0
    if include1S and abs(P1) > 1e-12:
        S1 = W_LCC1*(L1/3.0) + Wp1*(L1/2.0) + Wt1*(L1/2.0)
        e1B_st = S1 / (W1_st if W1_st else 1)
        g1_st = e1B_st / math.cos(rad(beta))
        N1_st = W1_st * math.cos(rad(beta)) + P1 * math.sin(rad(beta))
        zp1_st = (g1_st * N1_st - S1) / (P1 if abs(P1)>1e-12 else 1)
        zp1_st = max(0.0, min(h_BC, zp1_st))
        M1_st = P1 * (zp1_st + h_soil)
    h_st = (gst * N_st - W2_st * x2_tot + M1_st) / (PA if abs(PA) > 1e-12 else float('nan'))
    return dict(alpha=alpha, PA=PA, h_st=h_st, PAE=PAE, h_ps=h_ps_ME)

# ---------- Evaluate Regime B at alpha ----------

def eval_regimeB(alpha: float, beta: float, phi: float, c_prime: float,
                 h1: float, h2: float, h3: float,
                 gam_soil: float, gam_lcc: float, gam_pav: float, surch: float,
                 KH: float) -> Dict:
    H, L2, LAB, V_LCC, V_soil = regimeB_geometry(alpha, beta, h1, h2)
    # Weights
    W_LCC = gam_lcc * V_LCC; W_soil = gam_soil * V_soil
    W_body= W_LCC + W_soil
    Wp = gam_pav * h3 * L2; Wt = surch * L2
    W_st = W_body + Wp + Wt
    W_ps = W_body + Wp
    # Thrusts
    P_st = thrust_P(W_st, alpha, phi, c_prime, LAB, 0.0)
    P_ps = thrust_P(W_ps, alpha, phi, c_prime, LAB, KH)
    # Pseudo centroid x and z (Regime B)
    x_tot = (H / math.tan(rad(alpha))) / 3.0
    x_LCC = (h2 / math.tan(rad(beta))) / 3.0
    A_tot = 0.5 * H * H / math.tan(rad(alpha))
    A_LCC = 0.5 * h2 * h2 / math.tan(rad(beta))
    A_soil= A_tot - A_LCC if A_tot - A_LCC != 0 else 1.0
    x_soil= (A_tot * x_tot - A_LCC * x_LCC) / A_soil
    x_body= (W_soil * x_soil + W_LCC * x_LCC) / (W_body if W_body else 1)
    x_ps = (W_body * x_body + Wp * (L2/2.0)) / (W_ps if W_ps else 1)
    g_ps = x_ps / math.cos(rad(alpha))
    # Vertical centroid
    z_tot = 2 * H / 3.0; z_LCC = h1 + 2 * h2 / 3.0
    z_soil= (A_tot * z_tot - A_LCC * z_LCC) / A_soil
    z_body= (W_soil * z_soil + W_LCC * z_LCC) / (W_body if W_body else 1)
    Z_ps  = (W_body * z_body + Wp * (H/2.0)) / (W_ps if W_ps else 1)
    # Base resultant and UPDATED ME height
    N_ps = W_ps * math.cos(rad(alpha)) - KH * W_ps * math.sin(rad(alpha)) + P_ps * math.sin(rad(alpha))
    h_ps_ME = (g_ps * N_ps - W_ps * x_ps + KH * W_ps * Z_ps) / (P_ps if abs(P_ps) > 1e-12 else float('nan'))
    # Static height (info)
    e_tot = (W_body * x_body + Wp * (L2/2.0) + Wt * (L2/2.0)) / (W_st if W_st else 1)
    gst = e_tot / math.cos(rad(alpha))
    N_st = W_st * math.cos(rad(alpha)) + P_st * math.sin(rad(alpha))
    h_st = (gst * N_st - W_st * e_tot) / (P_st if abs(P_st) > 1e-12 else float('nan'))
    return dict(alpha=alpha, PA=P_st, h_st=h_st, PAE=P_ps, h_ps=h_ps_ME)

# ---------- Envelope driver and final report ----------

def compute_v08r_noobj(*,
    h1: float, h2: float, h3: float,
    beta_deg: float, phi_deg: float, c_psf: float,
    gamma_soil: float, gamma_lcc: float, gamma_pav: float,
    surcharge_psf: float, kh: float,
    a_min: float=30.0, a_max: float=60.0, da: float=0.01
) -> Dict[str, float]:
    H = h1 + h2 + h3
    acrit = alpha_crit_from_geometry(h1,h2,beta_deg)
    rows = []
    a = a_min
    while a <= a_max + 1e-12:
        if a > acrit:
            rows.append(eval_regimeA(a,beta_deg,phi_deg,c_psf,h1,h2,h3,gamma_soil,gamma_lcc,gamma_pav,surcharge_psf,kh))
        else:
            rows.append(eval_regimeB(a,beta_deg,phi_deg,c_psf,h1,h2,h3,gamma_soil,gamma_lcc,gamma_pav,surcharge_psf,kh))
        a += da
    rows_pos = [r for r in rows if (r['PAE'] is not None and r['PAE']>0)]
    if not rows_pos:
        raise RuntimeError('No positive P_AE found in the sweep range.')
    r_pae = max(rows_pos, key=lambda r: r['PAE'])
    r_pa  = max(rows,     key=lambda r: r['PA']  if (r['PA'] is not None) else -1e30)
    alpha_fail = r_pae['alpha']
    PAE_max    = r_pae['PAE']
    PA_max     = r_pa['PA']
    hps_ME = r_pae['h_ps']
    hps_SW = (PA_max * (H/3.0) + 0.6*H * (PAE_max - PA_max)) / PAE_max
    return {
        'alpha_crit_deg': acrit,
        'alpha_failure_deg': alpha_fail,
        'regime_at_alpha_failure': ('A' if alpha_fail>acrit else 'B'),
        'PAE_max_lbft': PAE_max,
        'PA_max_lbft': PA_max,
        'h_ps_ME_ft': hps_ME,
        'h_ps_SW_ft': hps_SW
    }


# =============================================================================
# MP solver (with pavement + surcharge, and inertia arm nuance)
# =============================================================================

LAMBDA_MIN = 1e-12
EPS_BOUNDS = 1e-12

def clamp(v: float, lo: float, hi: float) -> float:
    return max(lo, min(hi, v))

def half_sine_f(n: int) -> np.ndarray:
    if n <= 0:
        raise ValueError("Need at least 1 slice.")
    idx = np.arange(n + 1, dtype=float)
    return np.sin(np.pi * idx / n)

def alpha_critical_deg(H: float, h1: float, beta_deg: float) -> float:
    beta = math.radians(beta_deg)
    denom = H - h1
    if abs(denom) < EPS_BOUNDS:
        denom = math.copysign(EPS_BOUNDS, denom if denom != 0 else 1.0)
    val = (H * math.tan(beta)) / denom
    return math.degrees(math.atan(val))

def h_soil_from_alpha(alpha_deg: float, h1: float, beta_deg: float) -> float:
    alpha = math.radians(alpha_deg)
    beta  = math.radians(beta_deg)
    t  = math.tan(alpha)
    tb = math.tan(beta)
    denom = t - tb
    if abs(denom) < EPS_BOUNDS:
        denom = math.copysign(EPS_BOUNDS, denom if denom != 0 else 1.0)
    return (t * h1) / denom

def _integrate_slice_materials(
    x0: float, x1: float, H: float, h1: float, beta: float, yb_func, x_samples: int
) -> Tuple[float, float, float, float, float, float]:
    xs = np.linspace(x0, x1, int(x_samples))
    tb = math.tan(beta)

    A_soil = A_lcc = 0.0
    Mx_soil = My_soil = 0.0
    Mx_lcc = My_lcc = 0.0

    def t_soil(yb_, yi_): return max(0.0, min(H, yi_) - yb_)
    def t_lcc (yb_, yi_): return max(0.0, H - max(yi_, yb_))

    for j in range(len(xs) - 1):
        xa = float(xs[j]); xb = float(xs[j+1])
        xm = 0.5*(xa+xb); dxx = xb - xa

        yb_a, yb_b, yb_m = yb_func(xa), yb_func(xb), yb_func(xm)
        yi_a, yi_b, yi_m = (h1 + xa*tb), (h1 + xb*tb), (h1 + xm*tb)

        ts_a, ts_b, ts_m = t_soil(yb_a, yi_a), t_soil(yb_b, yi_b), t_soil(yb_m, yi_m)
        tl_a, tl_b, tl_m = t_lcc (yb_a, yi_a), t_lcc (yb_b, yi_b), t_lcc (yb_m, yi_m)

        As = (dxx/6.0)*(ts_a + 4.0*ts_m + ts_b)
        Al = (dxx/6.0)*(tl_a + 4.0*tl_m + tl_b)

        Mx_soil += xm * As
        Mx_lcc  += xm * Al

        ys = (yb_m + 0.5*ts_m) if ts_m > 0 else 0.0
        yl = (H - 0.5*tl_m)    if tl_m > 0 else 0.0

        My_soil += ys * As
        My_lcc  += yl * Al

        A_soil += As
        A_lcc  += Al

    return A_soil, A_lcc, Mx_soil, My_soil, Mx_lcc, My_lcc

def _apply_cap_loads_and_centroids(
    *,
    A_soil: float, A_lcc: float,
    Mx_soil: float, My_soil: float, Mx_lcc: float, My_lcc: float,
    dx: float, x_mid: float,
    H: float,
    gamma_soil: float, gamma_lcc: float,
    # cap loads:
    h3: float, gamma_pav: float,
    surcharge_psf: float, include_surcharge: bool
) -> Tuple[float, float, float, float, float, float]:
    """
    Returns:
      W_total, x_c_total,
      y_sl (soil+LCC centroid height), y_inert (= y_sl),
      W_sl (soil+LCC weight), W_cap (pav + surcharge weights)
    """
    # Soil+LCC weights
    W_soil = gamma_soil * A_soil
    W_lcc  = gamma_lcc  * A_lcc
    W_sl   = W_soil + W_lcc
    if W_sl <= 0:
        raise RuntimeError("Non-positive soil+LCC slice weight.")

    # Soil+LCC centroid (used for inertia arm)
    x_sl = (gamma_soil*Mx_soil + gamma_lcc*Mx_lcc) / W_sl
    y_sl = (gamma_soil*My_soil + gamma_lcc*My_lcc) / W_sl

    # Cap loads at slice mid-width
    W_pav = gamma_pav * h3 * dx
    W_sur = (surcharge_psf * dx) if include_surcharge else 0.0
    W_cap = W_pav + W_sur

    W_total = W_sl + W_cap
    if W_total <= 0:
        raise RuntimeError("Non-positive total slice weight.")

    # Total x centroid includes cap loads at x_mid
    x_c = (W_sl * x_sl + W_cap * x_mid) / W_total

    # y used for inertial moment arm: DO NOT lift with pavement/surcharge
    y_inert = y_sl

    return W_total, x_c, y_sl, y_inert, W_sl, W_cap

def build_slices_regimeB(
    n: int, H: float, h1: float, alpha_deg: float, beta_deg: float,
    *,
    gamma_soil: float = 120.0, gamma_lcc: float = 40.0,
    # cap loads
    h3: float = 0.0, gamma_pav: float = 150.0,
    surcharge_psf: float = 0.0, include_surcharge: bool = True,
    x_samples_per_slice: int = 360
) -> List[Dict[str, float]]:
    alpha = math.radians(alpha_deg); beta = math.radians(beta_deg)
    ta = math.tan(alpha)
    if ta <= 0:
        raise ValueError("alpha must be > 0 for Regime B")

    x_end = H / ta
    dx = x_end / n
    L_nom = dx / math.cos(alpha)

    def yb(x): return x * ta

    slices: List[Dict[str, float]] = []
    for i in range(n):
        x0=i*dx; x1=(i+1)*dx; xm=0.5*(x0+x1); yb_mid=yb(xm)
        if yb_mid >= H:
            raise RuntimeError("Slice midpoint above H in Regime B; adjust n or geometry.")

        A_soil, A_lcc, Mx_soil, My_soil, Mx_lcc, My_lcc = _integrate_slice_materials(
            x0, x1, H, h1, beta, yb, x_samples_per_slice
        )

        W, x_c, y_sl, y_inert, W_sl, W_cap = _apply_cap_loads_and_centroids(
            A_soil=A_soil, A_lcc=A_lcc,
            Mx_soil=Mx_soil, My_soil=My_soil, Mx_lcc=Mx_lcc, My_lcc=My_lcc,
            dx=dx, x_mid=xm, H=H,
            gamma_soil=gamma_soil, gamma_lcc=gamma_lcc,
            h3=h3, gamma_pav=gamma_pav,
            surcharge_psf=surcharge_psf, include_surcharge=include_surcharge
        )

        slices.append(dict(
            dx=float(dx), L=float(L_nom), a=float(alpha),
            # total weight for force balance + inertia magnitude
            W=float(W),
            # x centroid includes cap loads
            x=float(x_c),
            # store y for completeness (soil+LCC centroid)
            y=float(y_sl),
            # inertia lever arm height (soil+LCC only)
            y_inert=float(y_inert),
            # debug
            W_sl=float(W_sl), W_cap=float(W_cap),
            x_base=float(xm), yb_base=float(yb_mid)
        ))

    return slices

def build_slices_regimeA(
    n: int, H: float, h1: float, alpha_deg: float, beta_deg: float, h_soil: float,
    *,
    gamma_soil: float = 120.0, gamma_lcc: float = 40.0,
    # cap loads
    h3: float = 0.0, gamma_pav: float = 150.0,
    surcharge_psf: float = 0.0, include_surcharge: bool = True,
    x_samples_per_slice: int = 360
) -> Tuple[List[Dict[str, float]], float]:
    alpha = math.radians(alpha_deg); beta = math.radians(beta_deg)
    ta = math.tan(alpha)
    if ta <= 0:
        raise ValueError("alpha must be > 0 for Regime A")

    x_end = h_soil / ta
    dx = x_end / n
    L_nom = dx / math.cos(alpha)

    def yb(x): return x * ta

    slices: List[Dict[str, float]] = []
    for i in range(n):
        x0=i*dx; x1=(i+1)*dx; xm=0.5*(x0+x1); yb_mid=yb(xm)
        if yb_mid >= H:
            raise RuntimeError("Slice midpoint above H in Regime A; adjust n or geometry.")

        A_soil, A_lcc, Mx_soil, My_soil, Mx_lcc, My_lcc = _integrate_slice_materials(
            x0, x1, H, h1, beta, yb, x_samples_per_slice
        )

        W, x_c, y_sl, y_inert, W_sl, W_cap = _apply_cap_loads_and_centroids(
            A_soil=A_soil, A_lcc=A_lcc,
            Mx_soil=Mx_soil, My_soil=My_soil, Mx_lcc=Mx_lcc, My_lcc=My_lcc,
            dx=dx, x_mid=xm, H=H,
            gamma_soil=gamma_soil, gamma_lcc=gamma_lcc,
            h3=h3, gamma_pav=gamma_pav,
            surcharge_psf=surcharge_psf, include_surcharge=include_surcharge
        )

        slices.append(dict(
            dx=float(dx), L=float(L_nom), a=float(alpha),
            W=float(W),
            x=float(x_c),
            y=float(y_sl),
            y_inert=float(y_inert),
            W_sl=float(W_sl), W_cap=float(W_cap),
            x_base=float(xm), yb_base=float(yb_mid)
        ))

    return slices, float(x_end)

def build_slices_auto_regime(
    H: float, h1: float, beta_deg: float, n_slices: int, alpha_failure_deg: float,
    *,
    gamma_soil: float, gamma_lcc: float,
    h3: float, gamma_pav: float,
    surcharge_psf: float, include_surcharge: bool
) -> Tuple[str, float, Optional[float], List[Dict[str, float]]]:
    acrit_deg = alpha_critical_deg(H, h1, beta_deg)

    if alpha_failure_deg < acrit_deg:
        regime = "B"
        slices = build_slices_regimeB(
            n_slices, H, h1, alpha_failure_deg, beta_deg,
            gamma_soil=gamma_soil, gamma_lcc=gamma_lcc,
            h3=h3, gamma_pav=gamma_pav,
            surcharge_psf=surcharge_psf, include_surcharge=include_surcharge
        )
        L2 = None
    else:
        regime = "A"
        h_s = h_soil_from_alpha(alpha_failure_deg, h1, beta_deg)
        eps = 1e-6
        h_s = clamp(h_s, h1 + eps, H - eps)
        slices, L2 = build_slices_regimeA(
            n_slices, H, h1, alpha_failure_deg, beta_deg, h_s,
            gamma_soil=gamma_soil, gamma_lcc=gamma_lcc,
            h3=h3, gamma_pav=gamma_pav,
            surcharge_psf=surcharge_psf, include_surcharge=include_surcharge
        )
    return regime, acrit_deg, L2, slices

def mp_march_wall_traction(
    FS: float, lam: float, E0: float,
    slices: List[Dict[str, float]],
    Pa: float, Ma: float, phi_deg: float, c_base: float, kh: float,
    *, regime: str
) -> Optional[np.ndarray]:
    """
    Residuals: r = [En, Mtot, Fx_res]

    - En terminal boundary condition.
    - Mtot includes:
        * external moment: -Ma  (with Ma = Pa*h)
        * weight moments: xC * (-W)
        * inertial moments: -y_inert * (-kh*W)
        * base-reaction moments: computed with projection (xC, xC*tan(alpha))
    """
    phi = math.radians(phi_deg)
    tan_phi = math.tan(phi)

    n = len(slices)
    f = half_sine_f(n)

    E = np.zeros(n + 1, dtype=float)
    E[0] = float(E0)

    Mtot = -float(Ma)

    c_eff   = float(c_base) / float(FS) if FS != 0 else 1e30
    tan_eff = float(tan_phi) / float(FS) if FS != 0 else 1e30

    sum_Fx_in   = 0.0
    sum_Fx_base = 0.0

    for i, sl in enumerate(slices):
        W  = sl["W"]; a  = sl["a"]; L  = sl["L"]
        xC = sl["x"]; yC = sl["y"]
        yI = sl.get("y_inert", yC)
        xB = sl["x_base"]; yB = sl["yb_base"]  # available if you later restore kink logic

        cos_a = math.cos(a); sin_a = math.sin(a)

        # External horizontal (pseudo-static inertia + applied Pa on first slice)
        Fx_in = -kh * W
        if i == 0:
            Fx_in += Pa
        sum_Fx_in += Fx_in

        EiL = E[i]
        XiL = lam * f[i] * EiL
        fR  = f[i+1]

        A = (tan_eff * cos_a - sin_a)
        B = (tan_eff * sin_a + cos_a)

        rhs_const = (XiL - W + c_eff*L*sin_a)
        lhs_const = lam * fR * (EiL + Fx_in + c_eff*L*cos_a)

        denom = (lam * fR * A - B)
        if abs(denom) < 1e-14:
            return None

        N   = (rhs_const - lhs_const) / denom
        EiR = EiL + Fx_in + c_eff*L*cos_a + N*A
        E[i+1] = EiR

        S       = c_eff*L + N*tan_eff
        Fx_base = (-N*sin_a) + (S*cos_a)
        Fy_base = ( N*cos_a) + (S*sin_a)
        sum_Fx_base += Fx_base

        # Moments about origin:
        # inertial moment uses y_inert (soil+LCC centroid height only per your convention)
        Mtot += (-yI * (-kh * W))

        # weight moment uses x centroid that includes cap loads at x_mid
        Mtot += (xC * (-W))

        # Base reaction moment arm: projection (as used in your newer MP code)
        x_mr = xC
        y_mr = xC * math.tan(a)
        Mtot += (x_mr * Fy_base - y_mr * Fx_base)

    En = float(E[-1])
    Fx_res = (float(E[0]) - En) + sum_Fx_in + sum_Fx_base
    return np.array([En, Mtot, Fx_res], dtype=float)

def solve_inner_three_unknowns_scipy(
    *,
    slices: List[Dict[str, float]],
    Pa: float,
    h: float,
    phi_deg: float, c_base: float, kh: float,
    regime: str,
    fs_bounds=(0.95, 1.05),
    lam_bounds=(LAMBDA_MIN, 0.8),
    e0s_bounds=(-50.0, 50.0),
    x0=(1.0, 0.20, 0.0),  # (FS, lam, E0_s)
    scale_residuals: bool = True,
) -> Dict[str, float]:
    from scipy.optimize import least_squares

    Ma = Pa * h

    lb = np.array([fs_bounds[0], lam_bounds[0], e0s_bounds[0]], dtype=float)
    ub = np.array([fs_bounds[1], lam_bounds[1], e0s_bounds[1]], dtype=float)
    x0 = np.array([x0[0], x0[1], x0[2]], dtype=float)

    def rfun(x: np.ndarray) -> np.ndarray:
        FS, lam, E0_s = float(x[0]), float(x[1]), float(x[2])
        E0 = E0_s * Pa

        r = mp_march_wall_traction(
            FS, lam, E0, slices, Pa, Ma, phi_deg, c_base, kh,
            regime=regime
        )
        if r is None:
            return np.array([1e6, 1e6, 1e6], dtype=float)

        if scale_residuals:
            sF = max(abs(Pa), 1.0)
            sM = max(abs(Ma), 1.0)
            r = np.array([r[0]/sF, r[1]/sM, r[2]/sF], dtype=float)

        return r

    res = least_squares(
        rfun, x0, bounds=(lb, ub),
        jac="3-point", method="trf",
        xtol=1e-9, ftol=1e-9, gtol=1e-9,
        max_nfev=1200
    )

    FS, lam, E0_s = res.x
    E0 = E0_s * Pa

    r_end = mp_march_wall_traction(
        float(FS), float(lam), float(E0),
        slices, Pa, Ma, phi_deg, c_base, kh,
        regime=regime
    )
    if r_end is None:
        En = M = Fx = float("nan")
    else:
        En, M, Fx = map(float, r_end)

    return dict(
        success=bool(res.success),
        status=int(res.status),
        message=str(res.message),
        nfev=int(res.nfev),
        cost=float(res.cost),
        FS=float(FS), lam=float(lam),
        E0=float(E0), E0_s=float(E0_s),
        Pa=float(Pa), Ma=float(Ma), h=float(h),
        En=float(En), M=float(M), Fx=float(Fx),
    )

def find_h_for_FS1(
    *,
    slices: List[Dict[str, float]],
    Pa: float,
    phi_deg: float, c_base: float, kh: float,
    regime: str,
    h_min: float,
    h_max: float,
    scan_step: float = 1.0,
    bisect_iters: int = 60,
    fs_bounds=(0.95, 1.05),
    lam_bounds=(LAMBDA_MIN, 0.8),
) -> Dict[str, float]:
    """
    Outer solve for h such that FS(h)=1:
      - scan to bracket sign change of f(h)=FS(h)-1
      - bisection to refine
    """

    def eval_f(h: float, x0_guess) -> Tuple[float, Dict[str, float]]:
        sol = solve_inner_three_unknowns_scipy(
            slices=slices, Pa=Pa, h=h,
            phi_deg=phi_deg, c_base=c_base, kh=kh,
            regime=regime,
            fs_bounds=fs_bounds, lam_bounds=lam_bounds,
            e0s_bounds=(-50.0, 50.0),
            x0=x0_guess,
            scale_residuals=True
        )
        if not sol["success"] or not np.isfinite(sol["FS"]):
            return float("nan"), sol
        return sol["FS"] - 1.0, sol

    # Scan to bracket a sign change in FS-1
    h = float(h_min)
    last = None  # (h, f, sol)
    bracket = None
    x0_guess = (1.0, 0.20, 0.0)

    while h <= h_max + 1e-12:
        f, sol = eval_f(h, x0_guess)

        if np.isfinite(f):
            # continuation
            x0_guess = (sol["FS"], sol["lam"], sol["E0_s"])

            if last is not None:
                h0, f0, sol0 = last
                if f0 * f < 0.0:
                    bracket = (h0, h, f0, f, sol0, sol)
                    break

            last = (h, f, sol)

        h += scan_step

    if bracket is None:
        raise RuntimeError("Could not bracket FS(h)=1. Expand [h_min,h_max] or reduce scan_step.")

    hL, hR, fL, fR, solL, solR = bracket

    # Bisection
    x0_mid = (solL["FS"], solL["lam"], solL["E0_s"])
    for _ in range(bisect_iters):
        hM = 0.5 * (hL + hR)
        fM, solM = eval_f(hM, x0_mid)

        if not np.isfinite(fM):
            x0_mid = (1.0, 0.20, 0.0)
            fM, solM = eval_f(hM, x0_mid)
        if not np.isfinite(fM):
            break

        x0_mid = (solM["FS"], solM["lam"], solM["E0_s"])

        if abs(fM) < 1e-9:
            hL = hR = hM
            fL = fR = fM
            solL = solR = solM
            break

        if fL * fM < 0.0:
            hR, fR, solR = hM, fM, solM
        else:
            hL, fL, solL = hM, fM, solM

    if abs(fL) <= abs(fR):
        return {"h_star": float(hL), "FS_minus_1": float(fL), "sol": solL}
    return {"h_star": float(hR), "FS_minus_1": float(fR), "sol": solR}


# =============================================================================
# Unified driver: BTWM(static/pseudo) -> MP(static/pseudo) -> h_st and h_ps
# =============================================================================

def btwm_run_static_and_pseudo(
    *,
    h1: float, h2: float, h3: float,
    beta_deg: float, phi_deg: float, c_psf: float,
    gamma_soil: float, gamma_lcc: float, gamma_pav: float,
    surcharge_psf: float, kh_pseudo: float,
    a_min: float=30.0, a_max: float=60.0, da: float=0.01
) -> Dict[str, object]:
    bt_st = compute_v08r_noobj(
        h1=h1,h2=h2,h3=h3,
        beta_deg=beta_deg, phi_deg=phi_deg, c_psf=c_psf,
        gamma_soil=gamma_soil, gamma_lcc=gamma_lcc, gamma_pav=gamma_pav,
        surcharge_psf=surcharge_psf, kh=0.0,
        a_min=a_min, a_max=a_max, da=da
    )
    bt_ps = compute_v08r_noobj(
        h1=h1,h2=h2,h3=h3,
        beta_deg=beta_deg, phi_deg=phi_deg, c_psf=c_psf,
        gamma_soil=gamma_soil, gamma_lcc=gamma_lcc, gamma_pav=gamma_pav,
        surcharge_psf=surcharge_psf, kh=kh_pseudo,
        a_min=a_min, a_max=a_max, da=da
    )

    # Static: use PA_max and its alpha_failure
    Pa_static = float(bt_st["PA_max_lbft"])
    alpha_static = float(bt_st["alpha_failure_deg"])

    # Pseudo: use PAE_max and its alpha_failure
    Pa_pseudo = float(bt_ps["PAE_max_lbft"])
    alpha_pseudo = float(bt_ps["alpha_failure_deg"])

    return {
        "btwm_static": bt_st,
        "btwm_pseudo": bt_ps,
        "Pa_static": Pa_static,
        "alpha_static_deg": alpha_static,
        "Pa_pseudo": Pa_pseudo,
        "alpha_pseudo_deg": alpha_pseudo,
    }

def solve_h_st_and_h_ps(
    *,
    # BTWM inputs
    h1: float, h2: float, h3: float,
    beta_deg: float, phi_deg: float, c_psf: float,
    gamma_soil: float, gamma_lcc: float, gamma_pav: float,
    surcharge_psf: float,
    kh_pseudo: float,
    # MP controls
    n_slices: int = 3,
    c_base: float = 0.0,
    # h ranges
    h_search_static: Tuple[float,float] = (5.0, 35.0),
    h_search_pseudo: Tuple[float,float] = (5.0, 35.0),
    scan_step: float = 1.0,
    # bounds
    fs_bounds: Tuple[float,float] = (0.95, 1.05),
    lam_bounds: Tuple[float,float] = (LAMBDA_MIN, 0.8),
) -> Dict[str, object]:

    bt = btwm_run_static_and_pseudo(
        h1=h1,h2=h2,h3=h3,
        beta_deg=beta_deg, phi_deg=phi_deg, c_psf=c_psf,
        gamma_soil=gamma_soil, gamma_lcc=gamma_lcc, gamma_pav=gamma_pav,
        surcharge_psf=surcharge_psf, kh_pseudo=kh_pseudo
    )

    H_total = h1 + h2 + h3  # keep consistent with BTWM V08R convention

    # --- STATIC MP: include pavement + surcharge ---
    reg_st, acrit_st, L2_st, slices_st = build_slices_auto_regime(
        H=H_total, h1=h1, beta_deg=beta_deg, n_slices=n_slices,
        alpha_failure_deg=bt["alpha_static_deg"],
        gamma_soil=gamma_soil, gamma_lcc=gamma_lcc,
        h3=h3, gamma_pav=gamma_pav,
        surcharge_psf=surcharge_psf, include_surcharge=True
    )
    out_st = find_h_for_FS1(
        slices=slices_st, Pa=bt["Pa_static"],
        phi_deg=phi_deg, c_base=c_base, kh=0.0,
        regime=reg_st,
        h_min=h_search_static[0], h_max=h_search_static[1],
        scan_step=scan_step,
        fs_bounds=fs_bounds, lam_bounds=lam_bounds
    )

    # --- PSEUDO MP: include pavement only (no traffic surcharge) ---
    reg_ps, acrit_ps, L2_ps, slices_ps = build_slices_auto_regime(
        H=H_total, h1=h1, beta_deg=beta_deg, n_slices=n_slices,
        alpha_failure_deg=bt["alpha_pseudo_deg"],
        gamma_soil=gamma_soil, gamma_lcc=gamma_lcc,
        h3=h3, gamma_pav=gamma_pav,
        surcharge_psf=surcharge_psf, include_surcharge=False
    )
    out_ps = find_h_for_FS1(
        slices=slices_ps, Pa=bt["Pa_pseudo"],
        phi_deg=phi_deg, c_base=c_base, kh=kh_pseudo,
        regime=reg_ps,
        h_min=h_search_pseudo[0], h_max=h_search_pseudo[1],
        scan_step=scan_step,
        fs_bounds=fs_bounds, lam_bounds=lam_bounds
    )

    return {
        "btwm": bt,
        "static": {
            "Pa": bt["Pa_static"],
            "alpha_failure_deg": bt["alpha_static_deg"],
            "regime": reg_st,
            "alpha_critical_deg": acrit_st,
            "L2": L2_st,
            "h_st": out_st["h_star"],
            "inner": out_st["sol"],
            "slices": slices_st,
        },
        "pseudo": {
            "Pa": bt["Pa_pseudo"],
            "alpha_failure_deg": bt["alpha_pseudo_deg"],
            "kh": kh_pseudo,
            "regime": reg_ps,
            "alpha_critical_deg": acrit_ps,
            "L2": L2_ps,
            "h_ps": out_ps["h_star"],
            "inner": out_ps["sol"],
            "slices": slices_ps,
        },
    }


# =============================================================================
# Example run (your BTWM example inputs)
# =============================================================================

if __name__ == "__main__":
    # BTWM example inputs
    h1=3.0; h2=35.0; h3=2.0
    beta_deg=45.0; phi_deg=34.0; c_psf=0.0
    gamma_soil=120.0; gamma_lcc=40.0; gamma_pav=150.0
    surcharge_psf=240.0; kh_pseudo=0.16

    result = solve_h_st_and_h_ps(
        h1=h1,h2=h2,h3=h3,
        beta_deg=beta_deg, phi_deg=phi_deg, c_psf=c_psf,
        gamma_soil=gamma_soil, gamma_lcc=gamma_lcc, gamma_pav=gamma_pav,
        surcharge_psf=surcharge_psf,
        kh_pseudo=kh_pseudo,
        n_slices=3,
        c_base=0.0,
        h_search_static=(5.0, 35.0),
        h_search_pseudo=(5.0, 35.0),
        scan_step=1.0
    )

    st = result["static"]
    ps = result["pseudo"]

    print("\n=== BTWM -> MP results (with pavement+surcharge nuances) ===")

    print("\n--- STATIC (BTWM kh=0, MP kh=0; includes pavement + surcharge) ---")
    print(f"BTWM: Pa_static = {st['Pa']:.6f}, alpha_failure = {st['alpha_failure_deg']:.6f} deg, regime={st['regime']}")
    print(f"MP:   h_st = {st['h_st']:.6f} ft")
    s = st["inner"]
    print(f"      inner: FS={s['FS']:.9f}, lam={s['lam']:.9f}, E0_s={s['E0_s']:+.6f}, En={s['En']:+.2e}, M={s['M']:+.2e}, Fx={s['Fx']:+.2e}")

    print("\nSlice x_c (static) and weights (W_sl soil+LCC, W_cap pavement+surcharge):")
    for i, sl in enumerate(st["slices"]):
        print(f"  i={i}  x_c={sl['x']:.4f}  y_inert={sl['y_inert']:.4f}  W={sl['W']:.2f}  W_sl={sl['W_sl']:.2f}  W_cap={sl['W_cap']:.2f}")

    print("\n--- PSEUDO (BTWM kh=kh, MP kh=kh; includes pavement only, no surcharge; inertia arm not lifted) ---")
    print(f"BTWM: Pa_pseudo  = {ps['Pa']:.6f}, alpha_failure = {ps['alpha_failure_deg']:.6f} deg, regime={ps['regime']}, kh={ps['kh']:.3f}")
    print(f"MP:   h_ps = {ps['h_ps']:.6f} ft")
    p = ps["inner"]
    print(f"      inner: FS={p['FS']:.9f}, lam={p['lam']:.9f}, E0_s={p['E0_s']:+.6f}, En={p['En']:+.2e}, M={p['M']:+.2e}, Fx={p['Fx']:+.2e}")

    print("\nSlice x_c (pseudo) and weights (W_sl soil+LCC, W_cap pavement only):")
    for i, sl in enumerate(ps["slices"]):
        print(f"  i={i}  x_c={sl['x']:.4f}  y_inert={sl['y_inert']:.4f}  W={sl['W']:.2f}  W_sl={sl['W_sl']:.2f}  W_cap={sl['W_cap']:.2f}")