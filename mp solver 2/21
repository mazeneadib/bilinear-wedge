#!/usr/bin/env python3 """ mp_2slice_solver.py Two-slice Morgenstern–Price / GLE-style solver for Mazen Adib's active-wedge diagnostics. Key characteristics: - n = 2 slices over the full wedge width x_end (default 21.41808 ft) - Regime A bilinear base: y_base(x) = min(xtan(alpha), h1 + xtan(beta)) - Two materials (soil + LCC) with unit weights gamma_soil and gamma_lcc - Slice weights and centroids from numerical integration - Interslice function Half-Sine on normalized x (interfaces): for n=2 => f = [0, 1, 0] - Unknowns: (FS, lambda, dP) where E0 = Pa + dP - Solves 3 equations (choose closure): Fx: [En=0, SumFx=0, SumM_toe=0] Fy: [En=0, SumFy=0, SumM_toe=0] Notes: - With n=2, multiple valid roots can exist; Fy vs Fx closure can pick different roots. - For triangular case, Fx and Fy closures converge to essentially the same solution. - For uniform case, Slide2-matching root is obtained with Fy closure (FS≈0.9999, dP≈0). Author: generated for Mazen Adib audit (2026-02-22) """ from future import annotations import math import numpy as np from dataclasses import dataclass from typing import Dict, Tuple, Optional # ----------------------------- # Inputs (edit here if needed) # ----------------------------- # Geometry H = 38.0 h1 = 3.0 alpha_deg = 38.8943 beta_deg = 33.69 # Materials gamma_soil = 120.0 # pcf gamma_lcc = 40.0 # pcf # Strength and pseudo-static phi_deg = 30.0 c_base = 200.0 # psf kh = 0.16 # Slices n = 2 x_end = 21.41808 # ft (full wedge width to kink) # Cases Pa_uniform = 3948.2 hps_uniform = 19.0 pmax = 207.8947 Pa_tri = 0.5 * pmax * H hps_tri = (2.0/3.0) * H # ----------------------------- # Geometry helpers (Regime A) # ----------------------------- def y_int(x: float, h1: float, beta: float) -> float: return h1 + x * math.tan(beta) def y_base_regimeA(x: float, h1: float, alpha: float, beta: float) -> float: return min(x * math.tan(alpha), h1 + x * math.tan(beta)) def base_angle_regimeA(x: float, h1: float, alpha: float, beta: float) -> float: ya = x * math.tan(alpha) yb = h1 + x * math.tan(beta) return alpha if ya <= yb else beta @dataclass class Slice: i: int x0: float x1: float dx: float L: float a: float W: float xC: float yC: float xB: float yB: float def build_slices_equal( n: int, H: float, h1: float, alpha_deg: float, beta_deg: float, gamma_soil: float, gamma_lcc: float, x_end: float, ns: int = 8000, ) -> list[Slice]: """Build n equal-width slices over [0, x_end] and compute W and centroid (xC,yC).""" alpha = math.radians(alpha_deg) beta = math.radians(beta_deg) dx_nom = x_end / n def yb(x: float) -> float: return y_base_regimeA(x, h1, alpha, beta) def yi(x: float) -> float: return y_int(x, h1, beta) slices: list[Slice] = [] for i in range(n): x0 = i * dx_nom x1 = (i + 1) * dx_nom xm = 0.5 * (x0 + x1) a = base_angle_regimeA(xm, h1, alpha, beta) L = (x1 - x0) / math.cos(a) xs = np.linspace(x0, x1, ns) A_s = A_c = 0.0 Mx_s = Mx_c = 0.0 My_s = My_c = 0.0 for j in range(len(xs) - 1): xa = float(xs[j]); xb = float(xs[j + 1]) xm2 = 0.5 * (xa + xb) dxx = xb - xa yb_a, yb_b, yb_m = yb(xa), yb(xb), yb(xm2) yi_a, yi_b, yi_m = yi(xa), yi(xb), yi(xm2) # soil thickness between interior line and base (capped at H) ts_a = max(0.0, min(H, yi_a) - yb_a) ts_b = max(0.0, min(H, yi_b) - yb_b) ts_m = max(0.0, min(H, yi_m) - yb_m) # LCC thickness above max(interior, base) tl_a = max(0.0, H - max(yi_a, yb_a)) tl_b = max(0.0, H - max(yi_b, yb_b)) tl_m = max(0.0, H - max(yi_m, yb_m)) As = (dxx / 6.0) * (ts_a + 4.0 * ts_m + ts_b) Al = (dxx / 6.0) * (tl_a + 4.0 * tl_m + tl_b) A_s += As; A_c += Al Mx_s += xm2 * As; Mx_c += xm2 * Al ys = (yb_m + 0.5 * ts_m) if ts_m > 0 else 0.0 yl = (H - 0.5 * tl_m) if tl_m > 0 else 0.0 My_s += ys * As My_c += yl * Al W = gamma_soil * A_s + gamma_lcc * A_c xC = (gamma_soil * Mx_s + gamma_lcc * Mx_c) / W if W > 0 else 0.0 yC = (gamma_soil * My_s + gamma_lcc * My_c) / W if W > 0 else 0.0 slices.append( Slice( i=i + 1, x0=x0, x1=x1, dx=x1 - x0, L=L, a=a, W=W, xC=xC, yC=yC, xB=xm, yB=yb(xm), ) ) return slices def f_half_sine_interfaces(n: int) -> np.ndarray: """Half-sine on normalized x at interfaces. For n=2 => [0,1,0].""" xi = np.linspace(0.0, 1.0, n + 1) return np.sin(np.pi * xi) def mp_march( FS: float, lam: float, dP: float, Pa: float, hps: float, slices: list[Slice], f_arr: np.ndarray, phi_deg: float, c_base: float, kh: float, ) -> Optional[Dict[str, float]]: """March left->right and return En, SumFx, SumFy, SumM_toe and E0.""" n = len(slices) phi = math.radians(phi_deg) tan_phi = math.tan(phi) E = np.zeros(n + 1) E[0] = Pa + dP M = -Pa * hps c_eff = c_base / FS tan_eff = tan_phi / FS sumFx_in = 0.0 sumFx_base = 0.0 sumFy_base = 0.0 sumW = 0.0 for sl in slices: ca, sa = math.cos(sl.a), math.sin(sl.a) L = sl.L W = sl.W sumW += W Fx_in = -kh * W sumFx_in += Fx_in i = sl.i EiL = E[i - 1] kL = lam * f_arr[i - 1] kR = lam * f_arr[i] XiL = kL * EiL A = (tan_eff * ca - sa) B = (tan_eff * sa + ca) rhs = (XiL - W + c_eff * L * sa) lhs = kR * (EiL + Fx_in + c_eff * L * ca) denom = (kR * A - B) if abs(denom) < 1e-14: return None N = (rhs - lhs) / denom EiR = EiL + Fx_in + c_eff * L * ca + N * A E[i] = EiR S = c_eff * L + N * tan_eff Fx_base = (-N * sa) + (S * ca) Fy_base = ( N * ca) + (S * sa) sumFx_base += Fx_base sumFy_base += Fy_base # moment about toe M += (-sl.yC) * Fx_in + sl.xC * (-W) + (sl.xB * Fy_base - sl.yB * Fx_base) En = float(E[-1]) sumFx = (E[0] - E[-1]) + sumFx_in + sumFx_base sumFy = sumFy_base - sumW return { "En": En, "SumFx": sumFx, "SumFy": sumFy, "SumM_toe": M, "E0_eff": float(E[0]), } def solve_3eq( closure: str, seeds: list[Tuple[float, float, float]], Pa: float, hps: float, slices: list[Slice], f_arr: np.ndarray, phi_deg: float, c_base: float, kh: float, tol: float = 1e-10, max_iter: int = 140, ) -> Dict[str, float]: """Solve for (FS, lambda, dP) using [En=0, SumF*=0, SumM_toe=0].""" closure = closure.lower().strip() assert closure in ("fx", "fy") def residual(x: np.ndarray) -> Optional[Tuple[np.ndarray, Dict[str, float]]]: out = mp_march(float(x[0]), float(x[1]), float(x[2]), Pa, hps, slices, f_arr, phi_deg, c_base, kh) if out is None: return None r2 = out["SumFx"] if closure == "fx" else out["SumFy"] r = np.array([out["En"], r2, out["SumM_toe"]], float) return r, out def newton_lm(x0: Tuple[float, float, float]) -> Optional[Dict[str, float]]: x = np.array(x0, float) mu = 1e-2 ro = residual(x) if ro is None: return None for _ in range(max_iter): r, out = ro if np.linalg.norm(r, ord=np.inf) < tol: out2 = dict(out) out2["FS"] = float(x[0]) out2["lambda"] = float(x[1]) out2["dP"] = float(x[2]) out2["closure"] = closure out2["res_inf"] = float(np.linalg.norm(r, ord=np.inf)) return out2 # FD Jacobian J = np.zeros((3, 3), float) h = np.array([ 1e-6 * max(1.0, abs(x[0])), 1e-6 * max(1.0, abs(x[1])), 1e-6 * max(1000.0, abs(Pa), abs(x[2]) + 100.0), ]) r0 = r.copy() for k in range(3): xp = x.copy(); xp[k] += h[k] rp = residual(xp) if rp is None: return None rpp, _ = rp J[:, k] = (rpp - r0) / h[k] A = J.T @ J + mu * np.eye(3) g = J.T @ r0 try: dx = -np.linalg.solve(A, g) except np.linalg.LinAlgError: mu *= 4.0 continue base = float(np.sum(np.abs(r0))) step = 1.0 improved = False for _ in range(14): xt = x + step * dx xt[0] = max(0.05, xt[0]) # FS positive rt = residual(xt) if rt is not None: rv, _ = rt if float(np.sum(np.abs(rv))) < base * (1 - 1e-4): x = xt ro = rt mu = max(1e-7, mu / 3.0) improved = True break step *= 0.5 if not improved: mu = min(1e4, mu * 4.0) return None sols = [] for s in seeds: sol = newton_lm(s) if sol is not None: sols.append(sol) if not sols: raise RuntimeError("No solution found for provided seeds.") return min(sols, key=lambda d: abs(d["res_inf"])) def run_case(case_name: str, Pa: float, hps: float, slices: list[Slice], f_arr: np.ndarray): if case_name == "triangular": seeds = [(1.0, -0.6, 200.0), (1.0, -0.3, 0.0), (1.1, -0.5, 200.0), (0.9, -0.8, -200.0)] else: seeds = [(1.0, 0.8, -1e-3), (1.0, 0.6, 0.0), (1.0, 0.8, 0.0), (1.0, 0.6, 200.0), (0.9, 0.6, -200.0)] sol_fy = solve_3eq("Fy", seeds, Pa, hps, slices, f_arr, phi_deg, c_base, kh) sol_fx = solve_3eq("Fx", seeds, Pa, hps, slices, f_arr, phi_deg, c_base, kh) print(f"\n=== {case_name.upper()} ===") print(f"Pa={Pa:.6f} lb/ft, hps={hps:.6f} ft, x_end={x_end:.5f} ft, n={n}") print("Fy-closure:", sol_fy) print("Fx-closure:", sol_fx) def main(): slices = build_slices_equal(n, H, h1, alpha_deg, beta_deg, gamma_soil, gamma_lcc, x_end) f_arr = f_half_sine_interfaces(n) # [0,1,0] for n=2 run_case("triangular", Pa_tri, hps_tri, slices, f_arr) run_case("uniform", Pa_uniform, hps_uniform, slices, f_arr) if name == "main": main()