#!/usr/bin/env python3
# ======================================================================
# wedge_single_V06.py  (User-input only, no embedded numeric examples)
# Version: 2026-01-29 V.06 (final)
#To run with interactive prompt:
# python wedge_single_V06.py
#To run non interactive (all flags required)
#python wedge_single_V06.py --no-prompt \
#--h1 <ft> --h2 <ft> --h3 <ft> \
# --gam-soil <pcf> --gam-lcc <pcf> --gam-pave <pcf> --surch <psf> \
# --KH <-> --beta <deg> --phi <deg> --cprime <psf> \
# --amin <deg> --amax <deg> --dalpha <deg> --refine-band <deg> --refine-step <deg> \
# --json <path/to/log.json>
# Pseudo-static vertical centroid rules:
#   - Case A, Wedge 2: pavement vertical arm at H/2 (dead weight).
#   - Case A, Wedge 1: pavement vertical arm at h_BC/2 (dead weight on BC face).
#   - Case B (single wedge): pavement vertical arm at H/2 (dead weight).
#
# Rule-2:
#   If P1E <= 0, exclude M1_ps ONLY (do not force h_ps=0).
#
# Scan:
#   Global coarse scan over alpha plus local refinement around alpha_crit
#   (explicit inclusion of alpha_crit).
#
# Outputs:
#   - Console summary with governing static and pseudo-static picks (A or B),
#     corresponding alpha*, thrust, and resultant height.
#   - Optional JSON log (inputs, alpha_crit, detailed regime picks).
#
# Refer to Supplemental Material for notation.
# ======================================================================

import math
import argparse
import json
import sys
from datetime import datetime
from typing import Optional

rad = math.radians

# ------------------------- Prompt utilities ---------------------------

def _ensure_value(name: str, value: Optional[float]) -> float:
    if value is None:
        raise ValueError(f"Missing required input: {name}")
    try:
        return float(value)
    except Exception:
        raise ValueError(f"Invalid numeric value for {name}: {value}")

def _prompt_required_float(label: str) -> float:
    while True:
        s = input(f"{label}: ").strip()
        try:
            return float(s)
        except Exception:
            print("  Invalid entry. Please enter a numeric value.")

# ------------------------- Thrust mapping -----------------------------

def thrust_P(W: float, theta_deg: float, phi_deg: float,
             c_prime: float, Lc: float, kh_val: float) -> float:
    """
    P = [ W*((sinθ - cosθ*tanφ) + kh*(cosθ + sinθ*tanφ)) - c' * Lc ] / (cosθ + sinθ*tanφ)
    Static -> kh=0 ; Pseudo-static -> kh=K_H
    """
    s = math.sin(rad(theta_deg))
    c = math.cos(rad(theta_deg))
    tphi = math.tan(rad(phi_deg))
    den = (c + s * tphi)
    if abs(den) < 1e-12:
        den = 1e-12
    return (W * ((s - c * tphi) + kh_val * (c + s * tphi)) - c_prime * Lc) / den

# ------------------------- Geometry (Case A) --------------------------

def caseA_geometry(alpha: float, beta: float, h1: float, h2: float):
    ta = math.tan(rad(alpha))
    tb = math.tan(rad(beta))
    H = h1 + h2
    if abs(ta - tb) < 1e-12:
        ta += 1e-12
    h_soil = h1 * ta / (ta - tb)
    h_BC   = H - h_soil
    L1     = h_BC / math.tan(rad(beta))
    LBO    = L1 / math.cos(rad(beta))
    L2     = h2 / math.tan(rad(beta)) - L1
    LAB    = h_soil / math.sin(rad(alpha))
    return H, h_soil, h_BC, L1, LBO, L2, LAB

def wedge2_caseA_areas_centroids(alpha: float, beta: float, h1: float, h2: float):
    H, h_soil, h_BC, L1, LBO, L2, LAB = caseA_geometry(alpha, beta, h1, h2)

    # Wedge 2 subareas & centroids
    V_soil2 = 0.5 * h1 * L2
    x_S2 = L2 / 3.0
    z_S2 = (h1 + h_soil) / 3.0

    V_LCC2 = L2 * (H - 0.5 * (h1 + h_soil))

    denom = (2*H - h1 - h_soil)
    if abs(denom) < 1e-12:
        x_L2 = L2 / 2.0
        z_L2 = (H + h1) / 2.0
    else:
        x_L2 = L2 * (3*H - h1 - 2*h_soil) / (3 * denom)
        z_L2 = (H*H - (h_soil*h_soil + h1*h1 + h1*h_soil)/3.0) / denom

    return dict(H=H, h_soil=h_soil, h_BC=h_BC, L1=L1, LBO=LBO, L2=L2, LAB=LAB,
                V_soil2=V_soil2, x_S2=x_S2, z_S2=z_S2, V_LCC2=V_LCC2, x_L2=x_L2, z_L2=z_L2)

# ------------------------- Geometry (Case B) --------------------------

def caseB_geometry(alpha: float, beta: float, h1: float, h2: float):
    H = h1 + h2
    L2 = H / math.tan(rad(alpha))
    LAB = H / math.sin(rad(alpha))
    V_LCC = 0.5 * h2 * h2 / math.tan(rad(beta))
    V_tot = 0.5 * H * H / math.tan(rad(alpha))
    V_soil = V_tot - V_LCC
    return H, L2, LAB, V_LCC, V_soil

# ------------------------- Case A evaluator (V.06) --------------------

def evaluate_caseA_at_alpha_V06(alpha: float, beta: float, phi: float, c_prime: float,
                                h1: float, h2: float, h3: float,
                                gam_soil: float, gam_lcc: float, gam_pave: float, surch: float,
                                KH: float):
    g = wedge2_caseA_areas_centroids(alpha, beta, h1, h2)

    # Wedge 2 (masses)
    W_soil2 = gam_soil * g['V_soil2']
    W_LCC2  = gam_lcc  * g['V_LCC2']
    Wp2     = gam_pave * h3 * g['L2']
    Wt2     = surch    * g['L2']
    W2_body = W_soil2 + W_LCC2
    W2_st   = W2_body + Wp2 + Wt2
    W2_ps   = W2_body + Wp2   # surcharge excluded in ps

    # ps arms (V.06: pavement vertical at H/2)
    x2_ps = (W2_body*((W_soil2*g['x_S2'] + W_LCC2*g['x_L2'])/(W2_body if W2_body else 1))
             + Wp2*(g['L2']/2.0)) / (W2_ps if W2_ps else 1)
    z2_ps = (W2_body*((W_soil2*g['z_S2'] + W_LCC2*g['z_L2'])/(W2_body if W2_body else 1))
             + Wp2*(g['H']/2.0)) / (W2_ps if W2_ps else 1)

    # Wedge 1 (masses)
    V_LCC1 = 0.5 * g['L1'] * g['h_BC']
    W_LCC1 = gam_lcc * V_LCC1
    Wp1    = gam_pave * h3 * g['L1']
    Wt1    = surch * g['L1']
    W1_st  = W_LCC1 + Wp1 + Wt1
    W1_ps  = W_LCC1 + Wp1

    # Thrusts
    P1  = thrust_P(W1_st, beta,  phi, c_prime, g['LBO'], kh_val=0.0)
    P1E = thrust_P(W1_ps, beta,  phi, c_prime, g['LBO'], kh_val=KH)
    P2  = thrust_P(W2_st, alpha, phi, c_prime, g['LAB'], kh_val=0.0)
    P2E = thrust_P(W2_ps, alpha, phi, c_prime, g['LAB'], kh_val=KH)

    include1E = P1E > 0.0
    PAE = (P1E if include1E else 0.0) + P2E

    # ps normal on alpha-plane (Case A reference plane)
    N_ps = W2_ps * math.cos(rad(alpha)) - KH * W2_ps * math.sin(rad(alpha)) + P2E * math.sin(rad(alpha))

    # V.06 Wedge 1 vertical arm (pavement at h_BC/2)
    z1B_ps = (W_LCC1*(g['h_BC']*2.0/3.0) + Wp1*(g['h_BC']/2.0)) / (W1_ps if W1_ps else 1)

    # M1_ps branches (Rule-2)
    if not include1E:
        M1_ps = 0.0
    else:
        if P1 < 0.0:
            zp1_ps = z1B_ps
        else:
            # Full B-frame with KH term and clamping
            S1     = W_LCC1*(g['L1']/3.0) + Wp1*(g['L1']/2.0)
            e1B_ps = S1 / (W1_ps if W1_ps else 1)
            g1_ps  = e1B_ps / math.cos(rad(beta))
            N1_ps  = W1_ps * math.cos(rad(beta)) - KH * W1_ps * math.sin(rad(beta)) + P1E * math.sin(rad(beta))
            zp1_ps = (g1_ps * N1_ps - S1 + KH * W1_ps * z1B_ps) / (P1E if P1E else 1)
            if   zp1_ps < 0.0:       zp1_ps = 0.0
            elif zp1_ps > g['h_BC']: zp1_ps = g['h_BC']
        M1_ps = P1E * (zp1_ps + g['h_soil'])

    gps = x2_ps / math.cos(rad(alpha))
    h_ps = (gps * N_ps - W2_ps * x2_ps + KH * W2_ps * z2_ps + M1_ps) / (PAE if abs(PAE) > 1e-12 else float('nan'))

    # Static (informational)
    include1 = P1 > 0.0
    PA = (P1 if include1 else 0.0) + P2
    x2_tot = (W_soil2*g['x_S2'] + W_LCC2*g['x_L2'] + Wp2*(g['L2']/2.0) + Wt2*(g['L2']/2.0)) / (W2_st if W2_st else 1)
    gst    = x2_tot / math.cos(rad(alpha))
    N_st   = W2_st * math.cos(rad(alpha)) + P2 * math.sin(rad(alpha))
    M1_st  = 0.0
    if include1 and P1 != 0.0:
        S1     = W_LCC1*(g['L1']/3.0) + Wp1*(g['L1']/2.0) + Wt1*(g['L1']/2.0)
        e1B_st = S1 / (W1_st if W1_st else 1)
        g1_st  = e1B_st / math.cos(rad(beta))
        N1_st  = W1_st * math.cos(rad(beta)) + P1 * math.sin(rad(beta))
        zp1_st = (g1_st * N1_st - S1) / (P1 if P1 else 1)
        M1_st  = P1 * (zp1_st + g['h_soil'])
    h_st = (gst * N_st - W2_st * x2_tot + M1_st) / (PA if abs(PA) > 1e-12 else float('nan'))

    return dict(alpha=alpha, PA=PA, h_st=h_st, PAE=PAE, h_ps=h_ps)

# ------------------------- Case B evaluator (V.06) --------------------

def evaluate_caseB_at_alpha_V06(alpha: float, beta: float, phi: float, c_prime: float,
                                h1: float, h2: float, h3: float,
                                gam_soil: float, gam_lcc: float, gam_pave: float, surch: float,
                                KH: float):
    H, L2, LAB, V_LCC, V_soil = caseB_geometry(alpha, beta, h1, h2)
    W_LCC = gam_lcc  * V_LCC
    W_soil= gam_soil * V_soil
    W_body= W_LCC + W_soil
    Wp    = gam_pave * h3 * L2
    Wt    = surch * L2
    W_st  = W_body + Wp + Wt
    W_ps  = W_body + Wp

    P_st  = thrust_P(W_st, alpha, phi, c_prime, LAB, kh_val=0.0)
    P_ps  = thrust_P(W_ps, alpha, phi, c_prime, LAB, kh_val=KH)

    # Body centroid (strip subtraction)
    x_tot = H / math.tan(rad(alpha)) / 3.0; z_tot = 2 * H / 3.0
    x_LCC = h2 / math.tan(rad(beta)) / 3.0; z_LCC = h1 + 2 * h2 / 3.0
    A_tot = 0.5 * H * H / math.tan(rad(alpha))
    A_LCC = 0.5 * h2 * h2 / math.tan(rad(beta))
    A_soil= A_tot - A_LCC if A_tot - A_LCC != 0 else 1.0
    x_soil= (A_tot * x_tot - A_LCC * x_LCC) / A_soil
    z_soil= (A_tot * z_tot - A_LCC * z_LCC) / A_soil

    x_body= (W_soil * x_soil + W_LCC * x_LCC) / (W_body if W_body else 1)
    z_body= (W_soil * z_soil + W_LCC * z_LCC) / (W_body if W_body else 1)

    # ps arms (V.06: pavement vertical at H/2)
    x_ps  = (W_body * x_body + Wp * (L2/2.0)) / (W_ps if W_ps else 1)
    z_ps  = (W_body * z_body + Wp * (H/2.0)) / (W_ps if W_ps else 1)

    gps   = x_ps / math.cos(rad(alpha))
    N_ps  = W_ps * math.cos(rad(alpha)) - KH * W_ps * math.sin(rad(alpha)) + P_ps * math.sin(rad(alpha))
    h_ps  = (gps * N_ps - W_ps * x_ps + KH * W_ps * z_ps) / (P_ps if abs(P_ps) > 1e-12 else float('nan'))

    # Static (informational)
    e_tot = (W_body * x_body + Wp * (L2/2.0) + Wt * (L2/2.0)) / (W_st if W_st else 1)
    gst   = e_tot / math.cos(rad(alpha))
    N_st  = W_st * math.cos(rad(alpha)) + P_st * math.sin(rad(alpha))
    h_st  = (gst * N_st - W_st * e_tot) / (P_st if abs(P_st) > 1e-12 else float('nan'))

    return dict(alpha=alpha, PA=P_st, h_st=h_st, PAE=P_ps, h_ps=h_ps)

# ------------------------- One-run scan with refinement ---------------

def run_scan_single_V06(h1: float, h2: float, h3: float,
                        gam_soil: float, gam_lcc: float, gam_pave: float, surch: float,
                        KH: float, beta: float, phi: float, c_prime: float,
                        amin: float, amax: float, coarse_step: float,
                        refine_band: float, refine_step: float):
    H = h1 + h2
    alpha_crit = math.degrees(math.atan((H * math.tan(rad(beta))) / h2))

    # Build alpha list: coarse + local refinement (+ explicit alpha_crit)
    alphas = [amin + i*coarse_step for i in range(int((amax - amin)/coarse_step) + 1)]
    a_lo = max(amin, alpha_crit - refine_band)
    a_hi = min(amax, alpha_crit + refine_band)
    n_ref = int(round((a_hi - a_lo) / refine_step))
    fine  = [a_lo + i*refine_step for i in range(n_ref + 1)]
    fine.append(alpha_crit)

    all_alphas = sorted(set([round(a, 6) for a in (alphas + fine)]))

    A_list, B_list = [], []
    for a in all_alphas:
        if a > alpha_crit:
            A_list.append(evaluate_caseA_at_alpha_V06(
                a, beta, phi, c_prime, h1, h2, h3, gam_soil, gam_lcc, gam_pave, surch, KH))
        else:
            B_list.append(evaluate_caseB_at_alpha_V06(
                a, beta, phi, c_prime, h1, h2, h3, gam_soil, gam_lcc, gam_pave, surch, KH))

    def pick_max_pos(lst, key):
        pos = [d for d in lst if d[key] is not None and d[key] > 0]
        return max(pos, key=lambda d: d[key]) if pos else None

    return dict(
        alpha_crit=alpha_crit,
        A_st=pick_max_pos(A_list, 'PA'),  A_ps=pick_max_pos(A_list, 'PAE'),
        B_st=pick_max_pos(B_list, 'PA'),  B_ps=pick_max_pos(B_list, 'PAE')
    )

# ------------------------- CLI / Main ---------------------------------

def build_parser():
    p = argparse.ArgumentParser(
        description="V.06 single-scenario wedge solver (static & pseudo-static) with user inputs only."
    )
    p.add_argument("--no-prompt", action="store_true", help="Run non-interactively (all flags required).")

    # Geometry (required)
    p.add_argument("--h1", type=float, help="Soil height above toe h1 [ft].")
    p.add_argument("--h2", type=float, help="LCC thickness above toe h2 [ft].")
    p.add_argument("--h3", type=float, help="Pavement thickness h3 [ft].")

    # Materials (required)
    p.add_argument("--gam-soil", type=float, help="Unit weight of soil γ_s [pcf].")
    p.add_argument("--gam-lcc",  type=float, help="Unit weight of LCC γ_LCC [pcf].")
    p.add_argument("--gam-pave", type=float, help="Unit weight of pavement γ_p [pcf].")
    p.add_argument("--surch",    type=float, help="Uniform surcharge q [psf].")

    # Seismic/strength (required)
    p.add_argument("--KH",    type=float, help="Pseudo-static horizontal coefficient K_H [-].")
    p.add_argument("--beta",  type=float, help="Interface angle β [deg].")
    p.add_argument("--phi",   type=float, help="Friction angle φ [deg].")
    p.add_argument("--cprime", type=float, help="Cohesion c' [psf].")

    # Scan & refinement (required)
    p.add_argument("--amin", type=float, help="Alpha min [deg].")
    p.add_argument("--amax", type=float, help="Alpha max [deg].")
    p.add_argument("--dalpha", type=float, help="Coarse step Δα [deg].")
    p.add_argument("--refine-band", type=float, help="± band around alpha_crit for refinement [deg].")
    p.add_argument("--refine-step", type=float, help="Refined step [deg].")

    # Optional JSON log
    p.add_argument("--json", type=str, help="Write JSON log to file.")
    return p

def main():
    parser = build_parser()
    args = parser.parse_args()

    if args.no_prompt:
        # Require all flags
        h1   = _ensure_value("h1",   args.h1)
        h2   = _ensure_value("h2",   args.h2)
        h3   = _ensure_value("h3",   args.h3)
        gs   = _ensure_value("gam-soil", args.gam_soil)
        glcc = _ensure_value("gam-lcc",  args.gam_lcc)
        gp   = _ensure_value("gam-pave", args.gam_pave)
        q    = _ensure_value("surch",    args.surch)
        KH   = _ensure_value("KH",       args.KH)
        beta = _ensure_value("beta",     args.beta)
        phi  = _ensure_value("phi",      args.phi)
        cp   = _ensure_value("cprime",   args.cprime)
        amin = _ensure_value("amin",     args.amin)
        amax = _ensure_value("amax",     args.amax)
        da   = _ensure_value("dalpha",   args.dalpha)
        rbd  = _ensure_value("refine-band", args.refine_band)
        rst  = _ensure_value("refine-step", args.refine_step)
    else:
        # Interactive prompts (no defaults)
        print("\n--- V.06 Single-Scenario Input (all fields required) ---")
        h1   = _prompt_required_float("Enter h1 [ft]")
        h2   = _prompt_required_float("Enter h2 [ft]")
        h3   = _prompt_required_float("Enter h3 [ft]")

        gs   = _prompt_required_float("Enter γ_s (soil) [pcf]")
        glcc = _prompt_required_float("Enter γ_LCC [pcf]")
        gp   = _prompt_required_float("Enter γ_p (pavement) [pcf]")
        q    = _prompt_required_float("Enter uniform surcharge q [psf]")

        KH   = _prompt_required_float("Enter K_H [-]")
        beta = _prompt_required_float("Enter β [deg]")
        phi  = _prompt_required_float("Enter φ [deg]")
        cp   = _prompt_required_float("Enter c' [psf]")

        print("\n--- Scan Settings ---")
        amin = _prompt_required_float("Enter α_min [deg]")
        amax = _prompt_required_float("Enter α_max [deg]")
        da   = _prompt_required_float("Enter coarse step Δα [deg]")
        rbd  = _prompt_required_float("Enter refinement band ± [deg]")
        rst  = _prompt_required_float("Enter refinement step [deg]")

    # Run the scan
    res = run_scan_single_V06(
        h1=h1, h2=h2, h3=h3,
        gam_soil=gs, gam_lcc=glcc, gam_pave=gp, surch=q,
        KH=KH, beta=beta, phi=phi, c_prime=cp,
        amin=amin, amax=amax, coarse_step=da,
        refine_band=rbd, refine_step=rst
    )

    # Build console report
    now_utc = datetime.utcnow().isoformat() + "Z"
    print("\n=== V.06 Results (single scenario) ===")
    print(f"UTC: {now_utc}")
    print("Inputs:")
    print(f"  Geometry: h1={h1}, h2={h2}, h3={h3} [ft]")
    print(f"  Materials: γ_s={gs}, γ_LCC={glcc}, γ_p={gp} [pcf],  q={q} [psf]")
    print(f"  Strength: c'={cp} [psf], φ={phi} [deg], β={beta} [deg], K_H={KH}")
    print(f"  Scan: α∈[{amin},{amax}] [deg], Δα={da} [deg]; refine ±{rbd} [deg] @ {rst} [deg]")
    print(f"  α_crit = {res['alpha_crit']:.6f} [deg]")

    def show_block(tag, d, is_ps=False):
        if not d:
            print(f"{tag}: (none > 0)")
            return
        if is_ps:
            print(f"{tag}: Regime = {'A' if d is res['A_ps'] else 'B'} ; "
                  f"α*={d['alpha']:.6f} [deg] ; P_AE={d['PAE']:.2f} [lb/ft] ; h_ps={d['h_ps']:.2f} [ft]")
        else:
            print(f"{tag}: Regime = {'A' if d is res['A_st'] else 'B'} ; "
                  f"α*={d['alpha']:.6f} [deg] ; P_A={d['PA']:.2f} [lb/ft] ; h_st={d['h_st']:.2f} [ft]")

    print("\n-- Governing (maximum positive) --")
    show_block("Static", res['A_st'] if (res['A_st'] and (not res['B_st'] or res['A_st']['PA'] >= res['B_st']['PA'])) else res['B_st'])
    show_block("Pseudo-static", res['A_ps'] if (res['A_ps'] and (not res['B_ps'] or res['A_ps']['PAE'] >= res['B_ps']['PAE'])) else res['B_ps'], is_ps=True)

    # Optional JSON log
    if args.json:
        out = dict(
            meta=dict(version="2026-01-29 V.06", timestamp=now_utc),
            inputs=dict(h1=h1, h2=h2, h3=h3, gam_soil=gs, gam_lcc=glcc, gam_pave=gp,
                        surch=q, KH=KH, beta=beta, phi=phi, cprime=cp,
                        amin=amin, amax=amax, dalpha=da, refine_band=rbd, refine_step=rst),
            alpha_crit=res['alpha_crit'],
            results=res
        )
        with open(args.json, "w") as f:
            json.dump(out, f, indent=2)
        print(f"\nWrote JSON log: {args.json}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
