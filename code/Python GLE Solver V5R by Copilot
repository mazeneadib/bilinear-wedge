# -*- coding: utf-8 -*-
"""
MP/GLE (Half-sine) with wall traction supplied as (Pa, Ma).
- Pa is added once to the leftmost slice horizontal inputs (no distribution).
- The wall moment is included once as Mtot += -Ma about the toe.
- Pseudo-static inertia is Fx_inertia = -kh * W (leftwards for positive kh).
- Unknowns solved simultaneously: (FS, lambda, E0) s.t. En=0, M=0, Î£Fx=0.

Geometry / Materials:
 H = 38.0 ft, h1 = 3.0 ft, alpha = 38.8943 deg, beta = 33.69 deg,
 gamma_soil = 120.0 pcf, gamma_lcc = 40.0 pcf,
 phi = 30.0 deg, c = 200.0 psf, kh = 0.16 (left), kv = 0.

Slices: n = 2 (as requested)
"""

import math
import numpy as np

# -----------------------
# Helpers
# -----------------------
def clamp(v, lo, hi):
    return max(lo, min(hi, v))

def half_sine_f(n: int) -> np.ndarray:
    idx = np.arange(n + 1, dtype=float)
    return np.sin(np.pi * idx / n)  # f[0]=f[n]=0

def y_base_regimeB(x: float, alpha_rad: float) -> float:
    return x * math.tan(alpha_rad)

# -----------------------
# Cross-section integration for weights
# -----------------------
def _integrate_slice_materials(x0, x1, H, h1, beta, yb_func, x_samples):
    """Integrate soil/LCC areas and first moments over [x0,x1]."""
    xs = np.linspace(x0, x1, int(x_samples))
    tb = math.tan(beta)
    A_soil = A_lcc = 0.0
    Mx_soil = My_soil = 0.0
    Mx_lcc  = My_lcc  = 0.0

    def t_soil(yb_, yi_):
        return max(0.0, min(H, yi_) - yb_)
    def t_lcc(yb_, yi_):
        return max(0.0, H - max(yi_, yb_))

    for j in range(len(xs) - 1):
        xa = float(xs[j]); xb = float(xs[j+1])
        xm = 0.5*(xa+xb); dxx = xb - xa

        yb_a, yb_b, yb_m = yb_func(xa), yb_func(xb), yb_func(xm)
        yi_a, yi_b, yi_m = (h1 + xa*tb), (h1 + xb*tb), (h1 + xm*tb)

        ts_a, ts_b, ts_m = t_soil(yb_a, yi_a), t_soil(yb_b, yi_b), t_soil(yb_m, yi_m)
        tl_a, tl_b, tl_m = t_lcc (yb_a, yi_a), t_lcc (yb_b, yi_b), t_lcc (yb_m, yi_m)

        As = (dxx/6.0)*(ts_a + 4.0*ts_m + ts_b)
        Al = (dxx/6.0)*(tl_a + 4.0*tl_m + tl_b)

        Mx_soil += xm * As
        Mx_lcc  += xm * Al

        ys = (yb_m + 0.5*ts_m) if ts_m > 0 else 0.0
        yl = (H - 0.5*tl_m)    if tl_m > 0 else 0.0

        My_soil += ys * As
        My_lcc  += yl * Al

        A_soil += As
        A_lcc  += Al

    return A_soil, A_lcc, Mx_soil, My_soil, Mx_lcc, My_lcc

# -----------------------
# Slice builder (Regime B)
# -----------------------
def build_slices_regimeB(
    n, H, h1, alpha_deg, beta_deg, gamma_soil, gamma_lcc, x_samples_per_slice=240
):
    alpha = math.radians(alpha_deg)
    beta  = math.radians(beta_deg)
    ta = math.tan(alpha)
    x_end = H / ta
    dx = x_end / n
    cos_a = math.cos(alpha)
    L_nom = dx / cos_a

    def yb(x): return y_base_regimeB(x, alpha)

    slices = []
    for i in range(n):
        x0 = i*dx
        x1 = (i+1)*dx
        xm = 0.5*(x0+x1)
        yb_mid = yb(xm)
        if yb_mid >= H:
            continue

        A_soil, A_lcc, Mx_soil, My_soil, Mx_lcc, My_lcc = _integrate_slice_materials(
            x0, x1, H, h1, beta, yb, x_samples_per_slice
        )
        if (A_soil + A_lcc) <= 0:
            continue

        W = gamma_soil*A_soil + gamma_lcc*A_lcc
        if W <= 0:
            continue

        x_c = (gamma_soil*Mx_soil + gamma_lcc*Mx_lcc) / W
        y_c = (gamma_soil*My_soil + gamma_lcc*My_lcc) / W

        slices.append(dict(
            dx=float(dx), L=float(L_nom), a=float(alpha),
            W=float(W), x=float(x_c), y=float(y_c),
            x_base=float(xm), yb_base=float(yb_mid),
        ))

    if len(slices) != n:
        raise RuntimeError("Unexpected number of slices built.")
    return slices

# -----------------------
# MP / GLE march (Half-sine f)
# -----------------------
def mp_march_wall_traction(FS, lam, E0, slices, Pa, Ma, phi_deg, c_base, kh):
    """
    - Per-slice input: Fx_in = -kh*W (left) and +Pa on slice 0 only (resultant).
    - Global moment: Mtot starts with -Ma (toe convention).
    """
    phi = math.radians(phi_deg)
    tan_phi = math.tan(phi)

    n = len(slices)
    f = half_sine_f(n)

    E = np.zeros(n+1, dtype=float)
    E[0] = float(E0)

    Mtot = -float(Ma)

    c_eff   = float(c_base) / float(FS)
    tan_eff = float(tan_phi) / float(FS)

    sum_Fx_in   = 0.0
    sum_Fx_base = 0.0

    for i, sl in enumerate(slices):
        W = sl["W"]; a = sl["a"]; L = sl["L"]
        xC = sl["x"]; yC = sl["y"]
        xB = sl["x_base"]; yB = sl["yb_base"]

        cos_a = math.cos(a); sin_a = math.sin(a)

        # External horizontal input: inertia + (wall resultant only on slice 0)
        Fx_in = -kh * W
        if i == 0:
            Fx_in += Pa
        sum_Fx_in += Fx_in

        EiL = E[i]
        XiL = lam * f[i] * EiL
        fR  = f[i+1]

        A = (tan_eff * cos_a - sin_a)
        B = (tan_eff * sin_a + cos_a)

        rhs_const = (XiL - W + c_eff*L*sin_a)
        lhs_const = lam * fR * (EiL + Fx_in + c_eff*L*cos_a)

        denom = (lam*fR*A - B)
        if abs(denom) < 1e-14:
            return None

        N = (rhs_const - lhs_const) / denom

        EiR = EiL + Fx_in + c_eff*L*cos_a + N*A
        E[i+1] = EiR

        S = c_eff*L + N*tan_eff
        Fx_base = (-N*sin_a) + (S*cos_a)
        Fy_base = ( N*cos_a) + (S*sin_a)

        sum_Fx_base += Fx_base

        # Moments about toe:
        # - include inertia only here; wall is already Mtot = -Ma
        Mtot += (-yC * (-kh * W))
        Mtot += (xC * (-W))
        Mtot += (xB*Fy_base - yB*Fx_base)

    En = float(E[-1])

    # Global horizontal equilibrium residual
    Fx_res = (float(E0) - En) + sum_Fx_in + sum_Fx_base

    return np.array([En, Mtot, Fx_res], dtype=float)

# -----------------------
# Coupled solve for (FS, lambda, E0)
# -----------------------
def solve_coupled(
    slices, Pa, Ma, phi_deg, c_base, kh,
    x0=(1.0000, 0.0000, 0.0000),
    bounds=((0.20, 10.0), (-500.0, 500.0), (-50000.0, 50000.0)),
    tol=(1e-9, 1e-6, 1e-9),
    max_iter=120
):
    FS, lam, E0 = map(float, x0)

    def eval_res(FS_, lam_, E0_):
        out = mp_march_wall_traction(FS_, lam_, E0_, slices, Pa, Ma, phi_deg, c_base, kh)
        return out

    for it in range(1, max_iter+1):
        FS = clamp(FS, *bounds[0])
        lam = clamp(lam, *bounds[1])
        E0  = clamp(E0,  *bounds[2])

        r = eval_res(FS, lam, E0)
        if r is None:
            lam = clamp(lam + 1.0, *bounds[1])
            r = eval_res(FS, lam, E0)
            if r is None:
                raise RuntimeError("march singular near current iterate")

        if abs(r[0]) < tol[0] and abs(r[1]) < tol[1] and abs(r[2]) < tol[2]:
            return dict(FS=FS, lam=lam, E0=E0, En=float(r[0]), M=float(r[1]), Fx=float(r[2]), iters=it)

        steps = np.array([
            1e-5*max(1.0, abs(FS)),
            1e-4*max(1.0, abs(lam)),
            1e-4*max(1.0, abs(E0)),
        ], dtype=float)

        J = np.zeros((3,3), dtype=float)
        x = np.array([FS, lam, E0], dtype=float)

        for k in range(3):
            d = float(steps[k])
            xk = x.copy()
            xk[k] = clamp(xk[k] + d, *bounds[k])
            rk = eval_res(float(xk[0]), float(xk[1]), float(xk[2]))
            if rk is None:
                d *= 10.0
                xk = x.copy()
                xk[k] = clamp(xk[k] + d, *bounds[k])
                rk = eval_res(float(xk[0]), float(xk[1]), float(xk[2]))
                if rk is None:
                    raise RuntimeError("Jacobian eval failed (march singular).")
            J[:,k] = (rk - r) / d

        try:
            dx = np.linalg.solve(J, -r)
        except np.linalg.LinAlgError:
            dx = np.linalg.lstsq(J, -r, rcond=None)[0]

        # damping
        step = 1.0
        merit0 = float(np.sum(np.abs(r)))
        best = (merit0, FS, lam, E0, r)

        for _ in range(16):
            FS_t  = float(clamp(FS  + step*dx[0], *bounds[0]))
            lam_t = float(clamp(lam + step*dx[1], *bounds[1]))
            E0_t  = float(clamp(E0  + step*dx[2], *bounds[2]))
            rt = eval_res(FS_t, lam_t, E0_t)
            if rt is not None:
                merit = float(np.sum(np.abs(rt)))
                if merit < best[0]:
                    best = (merit, FS_t, lam_t, E0_t, rt)
                    break
            step *= 0.5

        _, FS, lam, E0, r = best

    raise RuntimeError("max_iter reached without convergence")

# -----------------------
# Run (2 slices) with your inputs
# -----------------------
if __name__ == "__main__":
    # Geometry / materials
    H = 38.0
    h1 = 3.0
    beta_deg  = 33.69
    alpha_deg = 38.8943

    gamma_soil = 120.0
    gamma_lcc  = 40.0

    phi_deg = 30.0
    c_base  = 200.0

    kh = 0.16    # left
    n_slices = 2

    # Build slices
    slices = build_slices_regimeB(n_slices, H, h1, alpha_deg, beta_deg, gamma_soil, gamma_lcc, x_samples_per_slice=400)

    # Case A: uniform pressure
    p0 = 103.9
    Pa_uniform = p0 * H
    Ma_uniform = p0 * H * H / 2.0
    ybar_uniform = Ma_uniform / Pa_uniform

    solA = solve_coupled(slices, Pa_uniform, Ma_uniform, phi_deg, c_base, kh, x0=(1.0000, 0.0000, 0.0000))

    print("\n--- CASE A: UNIFORM p(y)=103.9 psf on [0,38] ft ---")
    print(f"Pa   = {Pa_uniform:.10f} lb/ft")
    print(f"Ma   = {Ma_uniform:.10f} lb-ft/ft  (ybar={ybar_uniform:.10f} ft)")
    print(f"FS   = {solA['FS']:.12f}")
    print(f"lambda = {solA['lam']:.12f}")
    print(f"E0   = {solA['E0']:.12f} lb")
    print(f"En   = {solA['En']:.12e}")
    print(f"Mres = {solA['M']:.12e} lb-ft/ft")
    print(f"Fxres= {solA['Fx']:.12e} lb/ft")
    print(f"iters= {solA['iters']}")

    # Case B: inverted triangle p(y)=k*y with p(H)=207.9 psf
    pH = 207.9
    k  = pH / H
    Pa_inv = 0.5 * pH * H
    Ma_inv = (k * H**3) / 3.0
    ybar_inv = Ma_inv / Pa_inv

    # A few starts (GLE can have multiple nearby branches)
    starts = [
        (1.0000, 0.0000, 0.0000),
        (1.0500,-1.0000, 0.0000),
        (1.2000,-2.0000, 0.0000),
        (1.1000,-3.0000, 0.0000),
        (0.8000,-5.0000, 0.0000),
        (1.1000, 3.0000, 0.0000),
    ]
    sols = []
    for x0 in starts:
        try:
            sols.append( (x0, solve_coupled(slices, Pa_inv, Ma_inv, phi_deg, c_base, kh, x0=x0)) )
        except Exception as e:
            pass

    print("\n--- CASE B: INVERTED TRIANGLE p(0)=0, p(38)=207.9 psf ---")
    print(f"Pa   = {Pa_inv:.10f} lb/ft")
    print(f"Ma   = {Ma_inv:.10f} lb-ft/ft  (ybar={ybar_inv:.10f} ft)")
    for x0, sol in sols:
        print(f"start={x0}  FS={sol['FS']:.12f}  lambda={sol['lam']:.12f}  E0={sol['E0']:.12f}  "
              f"En={sol['En']:.2e}  Mres={sol['M']:.2e}  Fxres={sol['Fx']:.2e}  iters={sol['iters']}")
